<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://greensock.com/gsap/"

    >gsap (v1.19.1)</a>
</h1>
<h4>Think of GSAP as the Swiss Army Knife of animation...but better. It animates anything JavaScript can touch (CSS properties, canvas library objects, SVG, generic objects, whatever) and it solves countless browser inconsistencies, all with blazing speed (up</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap">module gsap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.gsap">
            function <span class="apidocSignatureSpan"></span>gsap
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackIn">
            function <span class="apidocSignatureSpan">gsap.</span>BackIn
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackInOut">
            function <span class="apidocSignatureSpan">gsap.</span>BackInOut
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackOut">
            function <span class="apidocSignatureSpan">gsap.</span>BackOut
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>BezierPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceIn">
            function <span class="apidocSignatureSpan">gsap.</span>BounceIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceInOut">
            function <span class="apidocSignatureSpan">gsap.</span>BounceInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceOut">
            function <span class="apidocSignatureSpan">gsap.</span>BounceOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>CSSPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSRulePlugin">
            function <span class="apidocSignatureSpan">gsap.</span>CSSRulePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircIn">
            function <span class="apidocSignatureSpan">gsap.</span>CircIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircInOut">
            function <span class="apidocSignatureSpan">gsap.</span>CircInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircOut">
            function <span class="apidocSignatureSpan">gsap.</span>CircOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>ColorPropsPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Cubic">
            function <span class="apidocSignatureSpan">gsap.</span>Cubic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Ease">
            function <span class="apidocSignatureSpan">gsap.</span>Ease
            <span class="apidocSignatureSpan">(func, extraParams, type, power)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticIn">
            function <span class="apidocSignatureSpan">gsap.</span>ElasticIn
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticInOut">
            function <span class="apidocSignatureSpan">gsap.</span>ElasticInOut
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticOut">
            function <span class="apidocSignatureSpan">gsap.</span>ElasticOut
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoIn">
            function <span class="apidocSignatureSpan">gsap.</span>ExpoIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoInOut">
            function <span class="apidocSignatureSpan">gsap.</span>ExpoInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoOut">
            function <span class="apidocSignatureSpan">gsap.</span>ExpoOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Linear">
            function <span class="apidocSignatureSpan">gsap.</span>Linear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Power0">
            function <span class="apidocSignatureSpan">gsap.</span>Power0
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Power1">
            function <span class="apidocSignatureSpan">gsap.</span>Power1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Power2">
            function <span class="apidocSignatureSpan">gsap.</span>Power2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Power3">
            function <span class="apidocSignatureSpan">gsap.</span>Power3
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Power4">
            function <span class="apidocSignatureSpan">gsap.</span>Power4
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Quad">
            function <span class="apidocSignatureSpan">gsap.</span>Quad
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Quart">
            function <span class="apidocSignatureSpan">gsap.</span>Quart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Quint">
            function <span class="apidocSignatureSpan">gsap.</span>Quint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.RoughEase">
            function <span class="apidocSignatureSpan">gsap.</span>RoughEase
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineIn">
            function <span class="apidocSignatureSpan">gsap.</span>SineIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineInOut">
            function <span class="apidocSignatureSpan">gsap.</span>SineInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineOut">
            function <span class="apidocSignatureSpan">gsap.</span>SineOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SlowMo">
            function <span class="apidocSignatureSpan">gsap.</span>SlowMo
            <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SteppedEase">
            function <span class="apidocSignatureSpan">gsap.</span>SteppedEase
            <span class="apidocSignatureSpan">(steps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Strong">
            function <span class="apidocSignatureSpan">gsap.</span>Strong
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite">
            function <span class="apidocSignatureSpan">gsap.</span>TimelineLite
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax">
            function <span class="apidocSignatureSpan">gsap.</span>TimelineMax
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite">
            function <span class="apidocSignatureSpan">gsap.</span>TweenLite
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax">
            function <span class="apidocSignatureSpan">gsap.</span>TweenMax
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>TweenPlugin
            <span class="apidocSignatureSpan">(props, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.allFrom">
            function <span class="apidocSignatureSpan">gsap.</span>allFrom
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.allFromTo">
            function <span class="apidocSignatureSpan">gsap.</span>allFromTo
            <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.allTo">
            function <span class="apidocSignatureSpan">gsap.</span>allTo
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.delayedCall">
            function <span class="apidocSignatureSpan">gsap.</span>delayedCall
            <span class="apidocSignatureSpan">(delay, callback, params, scope, useFrames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.from">
            function <span class="apidocSignatureSpan">gsap.</span>from
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.fromTo">
            function <span class="apidocSignatureSpan">gsap.</span>fromTo
            <span class="apidocSignatureSpan">(target, duration, fromVars, toVars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.getAllTweens">
            function <span class="apidocSignatureSpan">gsap.</span>getAllTweens
            <span class="apidocSignatureSpan">(includeTimelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.getTweensOf">
            function <span class="apidocSignatureSpan">gsap.</span>getTweensOf
            <span class="apidocSignatureSpan">(target, onlyActive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.globalTimeScale">
            function <span class="apidocSignatureSpan">gsap.</span>globalTimeScale
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.isTweening">
            function <span class="apidocSignatureSpan">gsap.</span>isTweening
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.killAll">
            function <span class="apidocSignatureSpan">gsap.</span>killAll
            <span class="apidocSignatureSpan">(complete, tweens, delayedCalls, timelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.killChildTweensOf">
            function <span class="apidocSignatureSpan">gsap.</span>killChildTweensOf
            <span class="apidocSignatureSpan">(parent, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.killDelayedCallsTo">
            function <span class="apidocSignatureSpan">gsap.</span>killDelayedCallsTo
            <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.killTweensOf">
            function <span class="apidocSignatureSpan">gsap.</span>killTweensOf
            <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.lagSmoothing">
            function <span class="apidocSignatureSpan">gsap.</span>lagSmoothing
            <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.pauseAll">
            function <span class="apidocSignatureSpan">gsap.</span>pauseAll
            <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.render">
            function <span class="apidocSignatureSpan">gsap.</span>render
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.resumeAll">
            function <span class="apidocSignatureSpan">gsap.</span>resumeAll
            <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.set">
            function <span class="apidocSignatureSpan">gsap.</span>set
            <span class="apidocSignatureSpan">(target, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.staggerFrom">
            function <span class="apidocSignatureSpan">gsap.</span>staggerFrom
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.staggerFromTo">
            function <span class="apidocSignatureSpan">gsap.</span>staggerFromTo
            <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.staggerTo">
            function <span class="apidocSignatureSpan">gsap.</span>staggerTo
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.to">
            function <span class="apidocSignatureSpan">gsap.</span>to
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>Back</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>BackIn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>BackInOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>BackOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>BezierPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>Bounce</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>BounceIn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>BounceInOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>BounceOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>CSSPlugin._internals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>CSSPlugin._internals.CSSPropTween.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>CSSPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>CSSRulePlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>Circ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>CircIn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>CircInOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>CircOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ColorPropsPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>Ease.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>EaseLookup</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>Elastic</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ElasticIn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ElasticInOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ElasticOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>Expo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ExpoIn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ExpoInOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ExpoOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>RoughEase.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>Sine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>SineIn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>SineInOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>SineOut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>SlowMo.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>SteppedEase.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TimelineLite._internals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TimelineLite.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TimelineMax.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._internals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.attr.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.directionalRotation.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.easel.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.endArray.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.modifiers.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.raphael.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.roundProps.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite._plugins.text.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenLite.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenMax.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>TweenPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.</span>ticker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BackIn">module gsap.BackIn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackIn.BackIn">
            function <span class="apidocSignatureSpan">gsap.</span>BackIn
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BackIn.prototype">module gsap.BackIn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackIn.prototype.config">
            function <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>config
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackIn.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>constructor
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackIn.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BackInOut">module gsap.BackInOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackInOut.BackInOut">
            function <span class="apidocSignatureSpan">gsap.</span>BackInOut
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BackInOut.prototype">module gsap.BackInOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackInOut.prototype.config">
            function <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>config
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackInOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackInOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BackOut">module gsap.BackOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackOut.BackOut">
            function <span class="apidocSignatureSpan">gsap.</span>BackOut
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BackOut.prototype">module gsap.BackOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackOut.prototype.config">
            function <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>config
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BackOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BezierPlugin">module gsap.BezierPlugin</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>_autoCSS</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.BezierPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>BezierPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin._cssRegister">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>_cssRegister
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.bezierThrough">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>bezierThrough
            <span class="apidocSignatureSpan">(values, curviness, quadratic, basic, correlate, prepend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.cubicToQuadratic">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>cubicToQuadratic
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.quadraticToCubic">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>quadraticToCubic
            <span class="apidocSignatureSpan">(a, b, c)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>API</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BezierPlugin.prototype">module gsap.BezierPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.prototype._kill">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_kill
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.prototype._mod">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_mod
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, vars, tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BezierPlugin.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BounceIn">module gsap.BounceIn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceIn.BounceIn">
            function <span class="apidocSignatureSpan">gsap.</span>BounceIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BounceIn.prototype">module gsap.BounceIn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceIn.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.BounceIn.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceIn.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.BounceIn.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BounceIn.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BounceIn.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BounceIn.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BounceInOut">module gsap.BounceInOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceInOut.BounceInOut">
            function <span class="apidocSignatureSpan">gsap.</span>BounceInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BounceInOut.prototype">module gsap.BounceInOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceInOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.BounceInOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceInOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.BounceInOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BounceInOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BounceInOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BounceInOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BounceOut">module gsap.BounceOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceOut.BounceOut">
            function <span class="apidocSignatureSpan">gsap.</span>BounceOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.BounceOut.prototype">module gsap.BounceOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.BounceOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.BounceOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.BounceOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BounceOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.BounceOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.BounceOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CSSPlugin">module gsap.CSSPlugin</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>defaultSmoothOrigin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>useSVGTransformAttr</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.CSSPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>CSSPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.cascadeTo">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>cascadeTo
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.colorStringFilter">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>colorStringFilter
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.getStyle">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>getStyle
            <span class="apidocSignatureSpan">(t, p, cs, calc, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.parseColor">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>parseColor
            <span class="apidocSignatureSpan">(v, toHSL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.parseComplex">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>parseComplex
            <span class="apidocSignatureSpan">(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.registerSpecialProp">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>registerSpecialProp
            <span class="apidocSignatureSpan">(name, onInitTween, priority)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>API</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>defaultTransformPerspective</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>_internals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>suffixMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>defaultSkewType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CSSPlugin._internals">module gsap.CSSPlugin._internals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.CSSPropTween">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>CSSPropTween
            <span class="apidocSignatureSpan">(t, p, s, c, next, type, n, r, pr, b, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.Transform">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>Transform
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals._parseToProxy">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_parseToProxy
            <span class="apidocSignatureSpan">(t, vars, cssp, pt, plugin, shallow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals._registerComplexSpecialProp">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_registerComplexSpecialProp
            <span class="apidocSignatureSpan">(p, options, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals._registerPluginProp">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_registerPluginProp
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals._setPluginRatio">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_setPluginRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.calculateOffset">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>calculateOffset
            <span class="apidocSignatureSpan">(t, p, cs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.convertToPixels">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>convertToPixels
            <span class="apidocSignatureSpan">(t, p, v, sfx, recurse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.getTransform">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>getTransform
            <span class="apidocSignatureSpan">(t, cs, rec, parse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.set3DTransformRatio">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>set3DTransformRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.setTransformRatio">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>setTransformRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_specialProps</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CSSPlugin._internals.CSSPropTween.prototype">module gsap.CSSPlugin._internals.CSSPropTween.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin._internals.CSSPropTween.prototype.appendXtra">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>appendXtra
            <span class="apidocSignatureSpan">(pfx, s, c, sfx, r, pad)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>l</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>pr</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn4</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn6</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn7</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xn8</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>_next</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>_prev</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>data</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>plugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>rxp</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>setRatio</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xfirst</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs0</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs4</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs6</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs7</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>xs8</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CSSPlugin.prototype">module gsap.CSSPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype._addLazySet">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_addLazySet
            <span class="apidocSignatureSpan">(t, p, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype._enableTransforms">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_enableTransforms
            <span class="apidocSignatureSpan">(threeD)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype._kill">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_kill
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype._linkCSSP">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_linkCSSP
            <span class="apidocSignatureSpan">(pt, next, prev, remove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype._mod">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_mod
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, vars, tween, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype.parse">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>parse
            <span class="apidocSignatureSpan">(target, vars, pt, plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSPlugin.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_firstPT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_lastParsedTransform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CSSRulePlugin">module gsap.CSSRulePlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSRulePlugin.CSSRulePlugin">
            function <span class="apidocSignatureSpan">gsap.</span>CSSRulePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSRulePlugin.getRule">
            function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.</span>getRule
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSRulePlugin.</span>API</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSRulePlugin.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CSSRulePlugin.prototype">module gsap.CSSRulePlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSRulePlugin.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSRulePlugin.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CSSRulePlugin.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CircIn">module gsap.CircIn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircIn.CircIn">
            function <span class="apidocSignatureSpan">gsap.</span>CircIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CircIn.prototype">module gsap.CircIn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircIn.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.CircIn.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircIn.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.CircIn.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CircIn.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CircIn.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CircIn.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CircInOut">module gsap.CircInOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircInOut.CircInOut">
            function <span class="apidocSignatureSpan">gsap.</span>CircInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CircInOut.prototype">module gsap.CircInOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircInOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.CircInOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircInOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.CircInOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CircInOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CircInOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CircInOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CircOut">module gsap.CircOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircOut.CircOut">
            function <span class="apidocSignatureSpan">gsap.</span>CircOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.CircOut.prototype">module gsap.CircOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.CircOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.CircOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.CircOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CircOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.CircOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.CircOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ColorPropsPlugin">module gsap.ColorPropsPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin.ColorPropsPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>ColorPropsPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin.colorStringFilter">
            function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.</span>colorStringFilter
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin.parseColor">
            function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.</span>parseColor
            <span class="apidocSignatureSpan">(v, toHSL)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.</span>API</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ColorPropsPlugin.prototype">module gsap.ColorPropsPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin.prototype._kill">
            function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_kill
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ColorPropsPlugin.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_firstNumPT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.Ease">module gsap.Ease</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Ease.Ease">
            function <span class="apidocSignatureSpan">gsap.</span>Ease
            <span class="apidocSignatureSpan">(func, extraParams, type, power)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Ease.register">
            function <span class="apidocSignatureSpan">gsap.Ease.</span>register
            <span class="apidocSignatureSpan">(ease, names, types, create)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.Ease.</span>map</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.Ease.prototype">module gsap.Ease.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.Ease.prototype.</span>_calcEnd</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.Ease.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.Ease.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.EaseLookup">module gsap.EaseLookup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.EaseLookup.find">
            function <span class="apidocSignatureSpan">gsap.EaseLookup.</span>find
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ElasticIn">module gsap.ElasticIn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticIn.ElasticIn">
            function <span class="apidocSignatureSpan">gsap.</span>ElasticIn
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ElasticIn.prototype">module gsap.ElasticIn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticIn.prototype.config">
            function <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>config
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticIn.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>constructor
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticIn.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ElasticInOut">module gsap.ElasticInOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticInOut.ElasticInOut">
            function <span class="apidocSignatureSpan">gsap.</span>ElasticInOut
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ElasticInOut.prototype">module gsap.ElasticInOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticInOut.prototype.config">
            function <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>config
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticInOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticInOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ElasticOut">module gsap.ElasticOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticOut.ElasticOut">
            function <span class="apidocSignatureSpan">gsap.</span>ElasticOut
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ElasticOut.prototype">module gsap.ElasticOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticOut.prototype.config">
            function <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>config
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ElasticOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ExpoIn">module gsap.ExpoIn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoIn.ExpoIn">
            function <span class="apidocSignatureSpan">gsap.</span>ExpoIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ExpoIn.prototype">module gsap.ExpoIn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoIn.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.ExpoIn.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoIn.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.ExpoIn.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ExpoIn.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ExpoIn.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ExpoIn.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ExpoInOut">module gsap.ExpoInOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoInOut.ExpoInOut">
            function <span class="apidocSignatureSpan">gsap.</span>ExpoInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ExpoInOut.prototype">module gsap.ExpoInOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoInOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.ExpoInOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoInOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.ExpoInOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ExpoInOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ExpoInOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ExpoInOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ExpoOut">module gsap.ExpoOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoOut.ExpoOut">
            function <span class="apidocSignatureSpan">gsap.</span>ExpoOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ExpoOut.prototype">module gsap.ExpoOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.ExpoOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ExpoOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.ExpoOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ExpoOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ExpoOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ExpoOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.RoughEase">module gsap.RoughEase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.RoughEase.RoughEase">
            function <span class="apidocSignatureSpan">gsap.</span>RoughEase
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.RoughEase.</span>ease</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.RoughEase.prototype">module gsap.RoughEase.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.RoughEase.prototype.config">
            function <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>config
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.RoughEase.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>constructor
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.RoughEase.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SineIn">module gsap.SineIn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineIn.SineIn">
            function <span class="apidocSignatureSpan">gsap.</span>SineIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SineIn.prototype">module gsap.SineIn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineIn.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.SineIn.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineIn.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.SineIn.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SineIn.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SineIn.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.SineIn.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SineInOut">module gsap.SineInOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineInOut.SineInOut">
            function <span class="apidocSignatureSpan">gsap.</span>SineInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SineInOut.prototype">module gsap.SineInOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineInOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.SineInOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineInOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.SineInOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SineInOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SineInOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.SineInOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SineOut">module gsap.SineOut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineOut.SineOut">
            function <span class="apidocSignatureSpan">gsap.</span>SineOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SineOut.prototype">module gsap.SineOut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineOut.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.SineOut.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SineOut.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.SineOut.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SineOut.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SineOut.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.SineOut.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SlowMo">module gsap.SlowMo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SlowMo.SlowMo">
            function <span class="apidocSignatureSpan">gsap.</span>SlowMo
            <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SlowMo.config">
            function <span class="apidocSignatureSpan">gsap.SlowMo.</span>config
            <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.SlowMo.</span>ease</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SlowMo.prototype">module gsap.SlowMo.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SlowMo.prototype.config">
            function <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>config
            <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SlowMo.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>constructor
            <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SlowMo.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SteppedEase">module gsap.SteppedEase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SteppedEase.SteppedEase">
            function <span class="apidocSignatureSpan">gsap.</span>SteppedEase
            <span class="apidocSignatureSpan">(steps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SteppedEase.config">
            function <span class="apidocSignatureSpan">gsap.SteppedEase.</span>config
            <span class="apidocSignatureSpan">(steps)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.SteppedEase.</span>ease</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.SteppedEase.prototype">module gsap.SteppedEase.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SteppedEase.prototype.config">
            function <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>config
            <span class="apidocSignatureSpan">(steps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SteppedEase.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>constructor
            <span class="apidocSignatureSpan">(steps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.SteppedEase.prototype.getRatio">
            function <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>getRatio
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>_power</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>_type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>_params</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TimelineLite">module gsap.TimelineLite</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.TimelineLite">
            function <span class="apidocSignatureSpan">gsap.</span>TimelineLite
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.exportRoot">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.</span>exportRoot
            <span class="apidocSignatureSpan">(vars, ignoreDelayedCalls)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineLite.</span>_internals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TimelineLite.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TimelineLite._internals">module gsap.TimelineLite._internals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite._internals.pauseCallback">
            function <span class="apidocSignatureSpan">gsap.TimelineLite._internals.</span>pauseCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TimelineLite.prototype">module gsap.TimelineLite.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_active</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_forcingPlayhead</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_gc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_hasPause</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_reversed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>autoRemoveChildren</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>smoothChildTiming</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype._contains">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_contains
            <span class="apidocSignatureSpan">(tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype._enabled">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_enabled
            <span class="apidocSignatureSpan">(enabled, ignoreTimeline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype._hasPausedChild">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_hasPausedChild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype._kill">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_kill
            <span class="apidocSignatureSpan">(vars, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype._parseTimeOrLabel">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_parseTimeOrLabel
            <span class="apidocSignatureSpan">(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype._remove">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_remove
            <span class="apidocSignatureSpan">(tween, skipDisable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.add">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>add
            <span class="apidocSignatureSpan">(value, position, align, stagger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.addLabel">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>addLabel
            <span class="apidocSignatureSpan">(label, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.addPause">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>addPause
            <span class="apidocSignatureSpan">(position, callback, params, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.append">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>append
            <span class="apidocSignatureSpan">(value, offsetOrLabel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.appendMultiple">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>appendMultiple
            <span class="apidocSignatureSpan">(tweens, offsetOrLabel, align, stagger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.call">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>call
            <span class="apidocSignatureSpan">(callback, params, scope, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.clear">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>clear
            <span class="apidocSignatureSpan">(labels)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>constructor
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.duration">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>duration
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.from">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>from
            <span class="apidocSignatureSpan">(target, duration, vars, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.fromTo">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>fromTo
            <span class="apidocSignatureSpan">(target, duration, fromVars, toVars, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.getChildren">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>getChildren
            <span class="apidocSignatureSpan">(nested, tweens, timelines, ignoreBeforeTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.getLabelTime">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>getLabelTime
            <span class="apidocSignatureSpan">(label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.getTweensOf">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>getTweensOf
            <span class="apidocSignatureSpan">(target, nested)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.gotoAndPlay">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>gotoAndPlay
            <span class="apidocSignatureSpan">(position, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.gotoAndStop">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>gotoAndStop
            <span class="apidocSignatureSpan">(position, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.insert">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>insert
            <span class="apidocSignatureSpan">(value, position, align, stagger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.insertMultiple">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>insertMultiple
            <span class="apidocSignatureSpan">(value, position, align, stagger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.invalidate">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>invalidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.paused">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>paused
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.rawTime">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>rawTime
            <span class="apidocSignatureSpan">(wrapRepeats)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.recent">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>recent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.remove">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>remove
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.removeLabel">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>removeLabel
            <span class="apidocSignatureSpan">(label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.render">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>render
            <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.seek">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>seek
            <span class="apidocSignatureSpan">(position, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.set">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>set
            <span class="apidocSignatureSpan">(target, vars, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.shiftChildren">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>shiftChildren
            <span class="apidocSignatureSpan">(amount, adjustLabels, ignoreBeforeTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.staggerFrom">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>staggerFrom
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.staggerFromTo">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>staggerFromTo
            <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.staggerTo">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>staggerTo
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.stop">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.to">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>to
            <span class="apidocSignatureSpan">(target, duration, vars, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.totalDuration">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>totalDuration
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.totalTime">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>totalTime
            <span class="apidocSignatureSpan">(time, suppressEvents, uncapped)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineLite.prototype.usesFrames">
            function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>usesFrames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_duration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_startTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_timeScale</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_totalDuration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_next</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_prev</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_timeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>timeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>vars</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TimelineMax">module gsap.TimelineMax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.TimelineMax">
            function <span class="apidocSignatureSpan">gsap.</span>TimelineMax
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TimelineMax.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TimelineMax.prototype">module gsap.TimelineMax.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_active</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_gc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_reversed</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_sortChildren</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>autoRemoveChildren</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>smoothChildTiming</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.addCallback">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>addCallback
            <span class="apidocSignatureSpan">(callback, position, params, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>constructor
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.currentLabel">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>currentLabel
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.getActive">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getActive
            <span class="apidocSignatureSpan">(nested, tweens, timelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.getLabelAfter">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getLabelAfter
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.getLabelBefore">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getLabelBefore
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.getLabelsArray">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getLabelsArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.invalidate">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>invalidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.progress">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>progress
            <span class="apidocSignatureSpan">(value, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.removeCallback">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>removeCallback
            <span class="apidocSignatureSpan">(callback, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.removePause">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>removePause
            <span class="apidocSignatureSpan">(position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.render">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>render
            <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.repeat">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>repeat
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.repeatDelay">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>repeatDelay
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.time">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>time
            <span class="apidocSignatureSpan">(value, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.totalDuration">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>totalDuration
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.totalProgress">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>totalProgress
            <span class="apidocSignatureSpan">(value, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.tweenFromTo">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>tweenFromTo
            <span class="apidocSignatureSpan">(fromPosition, toPosition, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.tweenTo">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>tweenTo
            <span class="apidocSignatureSpan">(position, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TimelineMax.prototype.yoyo">
            function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>yoyo
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_duration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_startTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_timeScale</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_totalDuration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_labels</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_next</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_prev</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>_timeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>timeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>vars</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite">module gsap.TweenLite</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.TweenLite">
            function <span class="apidocSignatureSpan">gsap.</span>TweenLite
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._onPluginEvent">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>_onPluginEvent
            <span class="apidocSignatureSpan">(type, tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.defaultStringFilter">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>defaultStringFilter
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.delayedCall">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>delayedCall
            <span class="apidocSignatureSpan">(delay, callback, params, scope, useFrames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.from">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>from
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.fromTo">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>fromTo
            <span class="apidocSignatureSpan">(target, duration, fromVars, toVars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.getTweensOf">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>getTweensOf
            <span class="apidocSignatureSpan">(target, onlyActive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.killDelayedCallsTo">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>killDelayedCallsTo
            <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.killTweensOf">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>killTweensOf
            <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.lagSmoothing">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>lagSmoothing
            <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.render">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>render
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.selector">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>selector
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.set">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>set
            <span class="apidocSignatureSpan">(target, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.to">
            function <span class="apidocSignatureSpan">gsap.TweenLite.</span>to
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite.</span>autoSleep</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.</span>_internals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.</span>_plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.</span>defaultEase</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.</span>ticker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite.</span>defaultOverwrite</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._internals">module gsap.TweenLite._internals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._internals.blobDif">
            function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>blobDif
            <span class="apidocSignatureSpan">(start, end, filter, pt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._internals.isArray">
            function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>isArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._internals.isSelector">
            function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>isSelector
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._internals.lazyRender">
            function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>lazyRender
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>lazyTweens</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>reservedProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>tweenLookup</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins">module gsap.TweenLite._plugins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.attr">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>attr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.bezier">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>bezier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.colorProps">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>colorProps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.css">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>css
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.cssRule">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>cssRule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>directionalRotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.easel">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>easel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.endArray">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>endArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.modifiers">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>modifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.raphael">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>raphael
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.roundProps">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>roundProps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.text">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.attr.prototype">module gsap.TweenLite._plugins.attr.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.attr.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.attr.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.directionalRotation.prototype">module gsap.TweenLite._plugins.directionalRotation.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(ratio)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.easel.prototype">module gsap.TweenLite._plugins.easel.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.easel.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.easel.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.easel.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.endArray.prototype">module gsap.TweenLite._plugins.endArray.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype._mod">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_mod
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(ratio)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.modifiers.prototype">module gsap.TweenLite._plugins.modifiers.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._add">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_add
            <span class="apidocSignatureSpan">(target, p, s, c, mod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._onInitAllProps">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_onInitAllProps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.raphael.prototype">module gsap.TweenLite._plugins.raphael.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype._parseTransform">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_parseTransform
            <span class="apidocSignatureSpan">(t, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.roundProps.prototype">module gsap.TweenLite._plugins.roundProps.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._add">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_add
            <span class="apidocSignatureSpan">(target, p, s, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._onInitAllProps">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_onInitAllProps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite._plugins.text.prototype">module gsap.TweenLite._plugins.text.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.text.prototype._onInitTween">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_onInitTween
            <span class="apidocSignatureSpan">(target, value, tween, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.text.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite._plugins.text.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(ratio)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_priority</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_overwriteProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_delimiter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_newClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_oldClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_propName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenLite.prototype">module gsap.TweenLite.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_active</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_gc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_lazy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_notifyPluginsOfEnabled</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_reversed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.prototype._enabled">
            function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_enabled
            <span class="apidocSignatureSpan">(enabled, ignoreTimeline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.prototype._init">
            function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.prototype._initProps">
            function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_initProps
            <span class="apidocSignatureSpan">(target, propLookup, siblings, overwrittenProps, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.prototype._kill">
            function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_kill
            <span class="apidocSignatureSpan">(vars, target, overwritingTween)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>constructor
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.prototype.invalidate">
            function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>invalidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenLite.prototype.render">
            function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>render
            <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_duration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_timeScale</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_totalDuration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>ratio</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_ease</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_firstPT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_overwrittenProps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_startAt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_targets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>vars</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenMax">module gsap.TweenMax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.TweenMax">
            function <span class="apidocSignatureSpan">gsap.</span>TweenMax
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.BackIn">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BackIn
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.BackInOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BackInOut
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.BackOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BackOut
            <span class="apidocSignatureSpan">(overshoot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.BezierPlugin">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BezierPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.BounceIn">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BounceIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.BounceInOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BounceInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.BounceOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BounceOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.CSSPlugin">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CSSPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.CSSRulePlugin">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CSSRulePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.CircIn">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CircIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.CircInOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CircInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.CircOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CircOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.ColorPropsPlugin">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ColorPropsPlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Cubic">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Cubic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Ease">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Ease
            <span class="apidocSignatureSpan">(func, extraParams, type, power)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.ElasticIn">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ElasticIn
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.ElasticInOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ElasticInOut
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.ElasticOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ElasticOut
            <span class="apidocSignatureSpan">(amplitude, period)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.ExpoIn">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ExpoIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.ExpoInOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ExpoInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.ExpoOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ExpoOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Linear">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Linear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Power0">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power0
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Power1">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Power2">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Power3">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power3
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Power4">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power4
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Quad">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Quad
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Quart">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Quart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Quint">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Quint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.RoughEase">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>RoughEase
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.SineIn">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SineIn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.SineInOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SineInOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.SineOut">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SineOut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.SlowMo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SlowMo
            <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.SteppedEase">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SteppedEase
            <span class="apidocSignatureSpan">(steps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.Strong">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Strong
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.TimelineLite">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TimelineLite
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.TimelineMax">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TimelineMax
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.TweenLite">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TweenLite
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.TweenPlugin">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TweenPlugin
            <span class="apidocSignatureSpan">(props, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.allFrom">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>allFrom
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.allFromTo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>allFromTo
            <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.allTo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>allTo
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.delayedCall">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>delayedCall
            <span class="apidocSignatureSpan">(delay, callback, params, scope, useFrames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.from">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>from
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.fromTo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>fromTo
            <span class="apidocSignatureSpan">(target, duration, fromVars, toVars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.getAllTweens">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>getAllTweens
            <span class="apidocSignatureSpan">(includeTimelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.getTweensOf">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>getTweensOf
            <span class="apidocSignatureSpan">(target, onlyActive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.globalTimeScale">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>globalTimeScale
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.isTweening">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>isTweening
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.killAll">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killAll
            <span class="apidocSignatureSpan">(complete, tweens, delayedCalls, timelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.killChildTweensOf">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killChildTweensOf
            <span class="apidocSignatureSpan">(parent, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.killDelayedCallsTo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killDelayedCallsTo
            <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.killTweensOf">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killTweensOf
            <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.lagSmoothing">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>lagSmoothing
            <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.pauseAll">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>pauseAll
            <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.render">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>render
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.resumeAll">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>resumeAll
            <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.set">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>set
            <span class="apidocSignatureSpan">(target, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.staggerFrom">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>staggerFrom
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.staggerFromTo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>staggerFromTo
            <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.staggerTo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>staggerTo
            <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.to">
            function <span class="apidocSignatureSpan">gsap.TweenMax.</span>to
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>Back</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>Bounce</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>Circ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>EaseLookup</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>Elastic</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>Expo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>Sine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.</span>ticker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenMax.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenMax.prototype">module gsap.TweenMax.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_active</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_gc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_lazy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_reversed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.constructor">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>constructor
            <span class="apidocSignatureSpan">(target, duration, vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.duration">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>duration
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.invalidate">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>invalidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.progress">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>progress
            <span class="apidocSignatureSpan">(value, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.render">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>render
            <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.repeat">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>repeat
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.repeatDelay">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>repeatDelay
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.time">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>time
            <span class="apidocSignatureSpan">(value, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.totalDuration">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>totalDuration
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.totalProgress">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>totalProgress
            <span class="apidocSignatureSpan">(value, suppressEvents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.updateTo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>updateTo
            <span class="apidocSignatureSpan">(vars, resetDuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenMax.prototype.yoyo">
            function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>yoyo
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_duration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_overwrite</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_startTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_timeScale</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_totalDuration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_next</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_prev</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_propLookup</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_siblings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>_timeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>target</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>timeline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>vars</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenPlugin">module gsap.TweenPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin.TweenPlugin">
            function <span class="apidocSignatureSpan">gsap.</span>TweenPlugin
            <span class="apidocSignatureSpan">(props, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin.activate">
            function <span class="apidocSignatureSpan">gsap.TweenPlugin.</span>activate
            <span class="apidocSignatureSpan">(plugins)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.TweenPlugin.</span>API</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gsap.TweenPlugin.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.TweenPlugin.prototype">module gsap.TweenPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin.prototype._addTween">
            function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_addTween
            <span class="apidocSignatureSpan">(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin.prototype._kill">
            function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_kill
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin.prototype._mod">
            function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_mod
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin.prototype._roundProps">
            function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_roundProps
            <span class="apidocSignatureSpan">(lookup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.TweenPlugin.prototype.setRatio">
            function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>setRatio
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_firstPT</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gsap.ticker">module gsap.ticker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ticker.fps">
            function <span class="apidocSignatureSpan">gsap.ticker.</span>fps
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ticker.lagSmoothing">
            function <span class="apidocSignatureSpan">gsap.ticker.</span>lagSmoothing
            <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ticker.sleep">
            function <span class="apidocSignatureSpan">gsap.ticker.</span>sleep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ticker.tick">
            function <span class="apidocSignatureSpan">gsap.ticker.</span>tick
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ticker.useRAF">
            function <span class="apidocSignatureSpan">gsap.ticker.</span>useRAF
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gsap.ticker.wake">
            function <span class="apidocSignatureSpan">gsap.ticker.</span>wake
            <span class="apidocSignatureSpan">(seamless)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ticker.</span>frame</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">gsap.ticker.</span>time</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ticker.</span>_eventTarget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">gsap.ticker.</span>_listeners</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap" id="apidoc.module.gsap">module gsap</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.gsap" id="apidoc.element.gsap.gsap">
        function <span class="apidocSignatureSpan"></span>gsap
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gsap = function (target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackIn" id="apidoc.element.gsap.BackIn">
        function <span class="apidocSignatureSpan">gsap.</span>BackIn
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackIn = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackInOut" id="apidoc.element.gsap.BackInOut">
        function <span class="apidocSignatureSpan">gsap.</span>BackInOut
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackInOut = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackOut" id="apidoc.element.gsap.BackOut">
        function <span class="apidocSignatureSpan">gsap.</span>BackOut
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackOut = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin" id="apidoc.element.gsap.BezierPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>BezierPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BezierPlugin = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BounceIn" id="apidoc.element.gsap.BounceIn">
        function <span class="apidocSignatureSpan">gsap.</span>BounceIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BounceInOut" id="apidoc.element.gsap.BounceInOut">
        function <span class="apidocSignatureSpan">gsap.</span>BounceInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BounceOut" id="apidoc.element.gsap.BounceOut">
        function <span class="apidocSignatureSpan">gsap.</span>BounceOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin" id="apidoc.element.gsap.CSSPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>CSSPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CSSPlugin = function () {
				TweenPlugin.call(this, &#x22;css&#x22;);
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSRulePlugin" id="apidoc.element.gsap.CSSRulePlugin">
        function <span class="apidocSignatureSpan">gsap.</span>CSSRulePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CSSRulePlugin = function () {
				TweenPlugin.call(this, &#x22;cssRule&#x22;);
				this._overwriteProps.length = 0;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CircIn" id="apidoc.element.gsap.CircIn">
        function <span class="apidocSignatureSpan">gsap.</span>CircIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CircInOut" id="apidoc.element.gsap.CircInOut">
        function <span class="apidocSignatureSpan">gsap.</span>CircInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CircOut" id="apidoc.element.gsap.CircOut">
        function <span class="apidocSignatureSpan">gsap.</span>CircOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin" id="apidoc.element.gsap.ColorPropsPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>ColorPropsPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ColorPropsPlugin = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Cubic" id="apidoc.element.gsap.Cubic">
        function <span class="apidocSignatureSpan">gsap.</span>Cubic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Cubic = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Ease" id="apidoc.element.gsap.Ease">
        function <span class="apidocSignatureSpan">gsap.</span>Ease
        <span class="apidocSignatureSpan">(func, extraParams, type, power)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Ease = function (func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticIn" id="apidoc.element.gsap.ElasticIn">
        function <span class="apidocSignatureSpan">gsap.</span>ElasticIn
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticIn = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticInOut" id="apidoc.element.gsap.ElasticInOut">
        function <span class="apidocSignatureSpan">gsap.</span>ElasticInOut
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticInOut = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticOut" id="apidoc.element.gsap.ElasticOut">
        function <span class="apidocSignatureSpan">gsap.</span>ElasticOut
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticOut = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ExpoIn" id="apidoc.element.gsap.ExpoIn">
        function <span class="apidocSignatureSpan">gsap.</span>ExpoIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ExpoInOut" id="apidoc.element.gsap.ExpoInOut">
        function <span class="apidocSignatureSpan">gsap.</span>ExpoInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ExpoOut" id="apidoc.element.gsap.ExpoOut">
        function <span class="apidocSignatureSpan">gsap.</span>ExpoOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Linear" id="apidoc.element.gsap.Linear">
        function <span class="apidocSignatureSpan">gsap.</span>Linear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Linear = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Power0" id="apidoc.element.gsap.Power0">
        function <span class="apidocSignatureSpan">gsap.</span>Power0
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power0 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Power1" id="apidoc.element.gsap.Power1">
        function <span class="apidocSignatureSpan">gsap.</span>Power1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power1 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Power2" id="apidoc.element.gsap.Power2">
        function <span class="apidocSignatureSpan">gsap.</span>Power2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power2 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Power3" id="apidoc.element.gsap.Power3">
        function <span class="apidocSignatureSpan">gsap.</span>Power3
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power3 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Power4" id="apidoc.element.gsap.Power4">
        function <span class="apidocSignatureSpan">gsap.</span>Power4
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power4 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Quad" id="apidoc.element.gsap.Quad">
        function <span class="apidocSignatureSpan">gsap.</span>Quad
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Quad = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Quart" id="apidoc.element.gsap.Quart">
        function <span class="apidocSignatureSpan">gsap.</span>Quart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Quart = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Quint" id="apidoc.element.gsap.Quint">
        function <span class="apidocSignatureSpan">gsap.</span>Quint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Quint = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.RoughEase" id="apidoc.element.gsap.RoughEase">
        function <span class="apidocSignatureSpan">gsap.</span>RoughEase
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RoughEase = function (vars) {
			vars = vars || {};
			var taper = vars.taper || &#x22;none&#x22;,
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === &#x22;number&#x22;) ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i &#x3e; -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === &#x22;none&#x22;) {
					bump = strength;
				} else if (taper === &#x22;out&#x22;) {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === &#x22;in&#x22;) {
					bump = x * x * strength;
				} else if (x &#x3c; 0.5) {  //&#x22;both&#x22; (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//&#x22;both&#x22; (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y &#x3e; 1) {
						y = 1;
					} else if (y &#x3c; 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i &#x3e; -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SineIn" id="apidoc.element.gsap.SineIn">
        function <span class="apidocSignatureSpan">gsap.</span>SineIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SineInOut" id="apidoc.element.gsap.SineInOut">
        function <span class="apidocSignatureSpan">gsap.</span>SineInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SineOut" id="apidoc.element.gsap.SineOut">
        function <span class="apidocSignatureSpan">gsap.</span>SineOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SlowMo" id="apidoc.element.gsap.SlowMo">
        function <span class="apidocSignatureSpan">gsap.</span>SlowMo
        <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SlowMo = function (linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio &#x3e; 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SteppedEase" id="apidoc.element.gsap.SteppedEase">
        function <span class="apidocSignatureSpan">gsap.</span>SteppedEase
        <span class="apidocSignatureSpan">(steps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SteppedEase = function (steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Strong" id="apidoc.element.gsap.Strong">
        function <span class="apidocSignatureSpan">gsap.</span>Strong
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Strong = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite" id="apidoc.element.gsap.TimelineLite">
        function <span class="apidocSignatureSpan">gsap.</span>TimelineLite
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimelineLite = function (vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax" id="apidoc.element.gsap.TimelineMax">
        function <span class="apidocSignatureSpan">gsap.</span>TimelineMax
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimelineMax = function (vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite" id="apidoc.element.gsap.TweenLite">
        function <span class="apidocSignatureSpan">gsap.</span>TweenLite
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenLite = function (target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)

				if (target == null) {
					throw &#x22;Cannot tween a null target.&#x22;;
				}

				this.target = target = (typeof(target) !== &#x22;string&#x22;) ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length &#x26;&#x26; target !== window &#x26;&#x26; target[0] &#x26;&#x26; (target[0] === window || (target[0].nodeType
 &#x26;&#x26; target[0].style &#x26;&#x26; !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === &#x22;number
&#x22;) ? overwrite &#x3e;&#x3e; 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push &#x26;&#x26; _isArray(target))) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
					this._targets = targets = _slice(target);  //don&#x27;t use Array.prototype.slice.call(target, 0) because that doesn&#x27;t work in IE8
 with a NodeList that&#x27;s returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i &#x3c; targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === &#x22;string&#x22;) {
							targ = targets[i--] = TweenLite.selector(targ); //in case it&#x27;s an array of strings
							if (typeof(targ) === &#x22;string&#x22;) {
								targets.splice(i+1, 1); //to avoid an endless loop (can&#x27;t imagine why the selector would return a string, but just in case
)
							}
							continue;
						} else if (targ.length &#x26;&#x26; targ !== window &#x26;&#x26; targ[0] &#x26;&#x26; (targ[0] === window || (targ[0].nodeType &#x26;&#x26; targ[0].style &#x26;&#x26; !targ
.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level
 and pull things out if necessary. Also note that &#x3c;select&#x3e; elements pass all the criteria regarding length and the first child having
 style, so we must also check to ensure the target isn&#x27;t an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length &#x3e; 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length &#x3e; 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 &#x26;&#x26; this._delay === 0 &#x26;&#x26; this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() &#x22;force&#x22; parameter to true because we want to allow
 lazying by default (using the &#x22;force&#x22; parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax" id="apidoc.element.gsap.TweenMax">
        function <span class="apidocSignatureSpan">gsap.</span>TweenMax
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenMax = function (target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin" id="apidoc.element.gsap.TweenPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>TweenPlugin
        <span class="apidocSignatureSpan">(props, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenPlugin = function (props, priority) {
					this._overwriteProps = (props || &#x22;&#x22;).split(&#x22;,&#x22;);
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.allFrom" id="apidoc.element.gsap.allFrom">
        function <span class="apidocSignatureSpan">gsap.</span>allFrom
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.allFromTo" id="apidoc.element.gsap.allFromTo">
        function <span class="apidocSignatureSpan">gsap.</span>allFromTo
        <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.allTo" id="apidoc.element.gsap.allTo">
        function <span class="apidocSignatureSpan">gsap.</span>allTo
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt &#x26;&#x26; vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === &#x22;string&#x22;) {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger &#x3c; 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i &#x3c;= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l &#x26;&#x26; onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.delayedCall" id="apidoc.element.gsap.delayedCall">
        function <span class="apidocSignatureSpan">gsap.</span>delayedCall
        <span class="apidocSignatureSpan">(delay, callback, params, scope, useFrames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayedCall = function (delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete
:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope
) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.<span class="apidocCodeKeywordSpan">delayedCall</span>(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time &#x26;&#x26; !this._paused);
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.from" id="apidoc.element.gsap.from">
        function <span class="apidocSignatureSpan">gsap.</span>from
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).<span class="apidocCodeKeywordSpan">from</span>(
target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.fromTo" id="apidoc.element.gsap.fromTo">
        function <span class="apidocSignatureSpan">gsap.</span>fromTo
        <span class="apidocSignatureSpan">(target, duration, fromVars, toVars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromTo = function (target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.<span class="apidocCodeKeywordSpan">fromTo</span>(target, duration, fromVars, toVars), position
) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope,
smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === &#x22;string&#x22;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.getAllTweens" id="apidoc.element.gsap.getAllTweens">
        function <span class="apidocSignatureSpan">gsap.</span>getAllTweens
        <span class="apidocSignatureSpan">(includeTimelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllTweens = function (includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines
) );
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.getTweensOf" id="apidoc.element.gsap.getTweensOf">
        function <span class="apidocSignatureSpan">gsap.</span>getTweensOf
        <span class="apidocSignatureSpan">(target, onlyActive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTweensOf = function (target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== &#x22;string&#x22;) ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
				i = target.length;
				a = [];
				while (--i &#x3e; -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i &#x3e; -1) {
					t = a[i];
					j = i;
					while (--j &#x3e; -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i &#x3e; -1) {
					if (a[i]._gc || (onlyActive &#x26;&#x26; !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline
 completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.<span class="apidocCodeKeywordSpan">getTweensOf</span>(target);
			i = tweens.length;
			while (--i &#x3e; -1) {
				if (tweens[i].timeline === this || (nested &#x26;&#x26; this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.globalTimeScale" id="apidoc.element.gsap.globalTimeScale">
        function <span class="apidocSignatureSpan">gsap.</span>globalTimeScale
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalTimeScale = function (value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can&#x27;t allow zero because it&#x27;ll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.isTweening" id="apidoc.element.gsap.isTweening">
        function <span class="apidocSignatureSpan">gsap.</span>isTweening
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTweening = function (target) {
			return (TweenLite.getTweensOf(target, true).length &#x3e; 0);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.killAll" id="apidoc.element.gsap.killAll">
        function <span class="apidocSignatureSpan">gsap.</span>killAll
        <span class="apidocSignatureSpan">(complete, tweens, delayedCalls, timelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killAll = function (complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens &#x26;&#x26; delayedCalls &#x26;&#x26; timelines),
				isDC, tween, i;
			for (i = 0; i &#x3c; l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) &#x26;&#x26; delayedCalls) || (
tweens &#x26;&#x26; !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.killChildTweensOf" id="apidoc.element.gsap.killChildTweensOf">
        function <span class="apidocSignatureSpan">gsap.</span>killChildTweensOf
        <span class="apidocSignatureSpan">(parent, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killChildTweensOf = function (parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === &#x22;string&#x22;) {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i &#x3e; -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i &#x3c; l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.killDelayedCallsTo" id="apidoc.element.gsap.killDelayedCallsTo">
        function <span class="apidocSignatureSpan">gsap.</span>killDelayedCallsTo
        <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killDelayedCallsTo = function (target, onlyActive, vars) {
			if (typeof(onlyActive) === &#x22;object&#x22;) {
				vars = onlyActive; //for backwards compatibility (before &#x22;onlyActive&#x22; parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i &#x3e; -1) {
				a[i]._kill(vars, target);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.killTweensOf" id="apidoc.element.gsap.killTweensOf">
        function <span class="apidocSignatureSpan">gsap.</span>killTweensOf
        <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killTweensOf = function (target, onlyActive, vars) {
			if (typeof(onlyActive) === &#x22;object&#x22;) {
				vars = onlyActive; //for backwards compatibility (before &#x22;onlyActive&#x22; parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i &#x3e; -1) {
				a[i]._kill(vars, target);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.lagSmoothing" id="apidoc.element.gsap.lagSmoothing">
        function <span class="apidocSignatureSpan">gsap.</span>lagSmoothing
        <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lagSmoothing = function (threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		TweenLite.version = &#x22;1.19.1&#x22;;
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = &#x22;auto&#x22;;
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.<span class="apidocCodeKeywordSpan">lagSmoothing</span>(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.pauseAll" id="apidoc.element.gsap.pauseAll">
        function <span class="apidocSignatureSpan">gsap.</span>pauseAll
        <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseAll = function (tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.render" id="apidoc.element.gsap.render">
        function <span class="apidocSignatureSpan">gsap.</span>render
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function () {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine
 refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame &#x3e;= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i &#x3e; -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they&#x27;re all paused, make the _timer sleep to reduce load on the
CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep &#x26;&#x26; !_rootFramesTimeline._first &#x26;&#x26; _ticker._listeners.tick.length === 1) {
						while (p &#x26;&#x26; p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (curTime !== this._time || (this._paused &#x26;&#x26; !prevPaused)) { //in case a tween pauses or seeks the timeline when
 rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime &#x3c;= curTime &#x26;&#x26; !tween._paused &#x26;&#x26; !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.<span class="apidocCodeKeywordSpan">render</span>((time - tween._startTime) * tween._timeScale, suppressEvents, force
);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale
), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.resumeAll" id="apidoc.element.gsap.resumeAll">
        function <span class="apidocSignatureSpan">gsap.</span>resumeAll
        <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resumeAll = function (tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.set" id="apidoc.element.gsap.set">
        function <span class="apidocSignatureSpan">gsap.</span>set
        <span class="apidocSignatureSpan">(target, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (target, vars) {
			return new TweenMax(target, 0, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.<span class="apidocCodeKeywordSpan">set</span
>(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.staggerFrom" id="apidoc.element.gsap.staggerFrom">
        function <span class="apidocSignatureSpan">gsap.</span>staggerFrom
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.staggerFromTo" id="apidoc.element.gsap.staggerFromTo">
        function <span class="apidocSignatureSpan">gsap.</span>staggerFromTo
        <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.staggerTo" id="apidoc.element.gsap.staggerTo">
        function <span class="apidocSignatureSpan">gsap.</span>staggerTo
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt &#x26;&#x26; vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === &#x22;string&#x22;) {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger &#x3c; 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i &#x3c;= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l &#x26;&#x26; onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.<span class="apidocCodeKeywordSpan">staggerTo</span>(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams
, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope
) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.to" id="apidoc.element.gsap.to">
        function <span class="apidocSignatureSpan">gsap.</span>to
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to = function (target, duration, vars) {
			return new TweenMax(target, duration, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.<span class="apidocCodeKeywordSpan">to</span>(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
...</pre></li>
    </ul>












































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BackIn" id="apidoc.module.gsap.BackIn">module gsap.BackIn</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BackIn.BackIn" id="apidoc.element.gsap.BackIn.BackIn">
        function <span class="apidocSignatureSpan">gsap.</span>BackIn
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackIn = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BackIn.prototype" id="apidoc.module.gsap.BackIn.prototype">module gsap.BackIn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BackIn.prototype.config" id="apidoc.element.gsap.BackIn.prototype.config">
        function <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>config
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (overshoot) {
					return new C(overshoot);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackIn.prototype.constructor" id="apidoc.element.gsap.BackIn.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>constructor
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackIn.prototype.getRatio" id="apidoc.element.gsap.BackIn.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.BackIn.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BackInOut" id="apidoc.module.gsap.BackInOut">module gsap.BackInOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BackInOut.BackInOut" id="apidoc.element.gsap.BackInOut.BackInOut">
        function <span class="apidocSignatureSpan">gsap.</span>BackInOut
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackInOut = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BackInOut.prototype" id="apidoc.module.gsap.BackInOut.prototype">module gsap.BackInOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BackInOut.prototype.config" id="apidoc.element.gsap.BackInOut.prototype.config">
        function <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>config
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (overshoot) {
					return new C(overshoot);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackInOut.prototype.constructor" id="apidoc.element.gsap.BackInOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackInOut.prototype.getRatio" id="apidoc.element.gsap.BackInOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.BackInOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
					return ((p *= 2) &#x3c; 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2
) + 2);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BackOut" id="apidoc.module.gsap.BackOut">module gsap.BackOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BackOut.BackOut" id="apidoc.element.gsap.BackOut.BackOut">
        function <span class="apidocSignatureSpan">gsap.</span>BackOut
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackOut = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BackOut.prototype" id="apidoc.module.gsap.BackOut.prototype">module gsap.BackOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BackOut.prototype.config" id="apidoc.element.gsap.BackOut.prototype.config">
        function <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>config
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (overshoot) {
					return new C(overshoot);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackOut.prototype.constructor" id="apidoc.element.gsap.BackOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BackOut.prototype.getRatio" id="apidoc.element.gsap.BackOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.BackOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BezierPlugin" id="apidoc.module.gsap.BezierPlugin">module gsap.BezierPlugin</a></h1>




    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.BezierPlugin" id="apidoc.element.gsap.BezierPlugin.BezierPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>BezierPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BezierPlugin = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin._cssRegister" id="apidoc.element.gsap.BezierPlugin._cssRegister">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>_cssRegister
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cssRegister = function () {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp(&#x22;bezier&#x22;, {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l &#x3c; 0) {
					return pt;
				}
				for (i = 0; i &#x3c;= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans
to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, &#x22;bezier&#x22;, 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate &#x26;&#x26; !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [[&#x22;left&#x22;,&#x22;top&#x22;,&#x22;rotation&#x22;,i,false]] : (data.end.x != null) ? [[&#x22;x&#x22;,&#x22;y&#x22;,&#x22;rotation&#x22;,
i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
					data.proxy.rotation = data.autoRotate.rotation || 0;
					cssp._overwriteProps.push(&#x22;rotation&#x22;);
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.bezierThrough" id="apidoc.element.gsap.BezierPlugin.bezierThrough">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>bezierThrough
        <span class="apidocSignatureSpan">(values, curviness, quadratic, basic, correlate, prepend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bezierThrough = function (values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === &#x22;string&#x22;) ? &#x22;,&#x22;+correlate+&#x22;,&#x22; : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second
element to the very end of the values array and the 2nd-to-last element to the very beginning (we&#x27;ll remove those segments later
)
				if (values.length &#x3e; 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i &#x3e; -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) &#x3e; 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors.
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other
 tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i &#x3e; -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(&#x22;,&#x22;+p+&#x22;,&#x22;) !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i &#x3e; -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i &#x3e; -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j &#x3c; l; j++) {
								r = (a[j+1].da / _r2[j] + a[j].da / _r1[j]) || 0;
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i &#x3e; -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i &#x3e; -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios
() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.cubicToQuadratic" id="apidoc.element.gsap.BezierPlugin.cubicToQuadratic">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>cubicToQuadratic
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cubicToQuadratic = function (a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.quadraticToCubic" id="apidoc.element.gsap.BezierPlugin.quadraticToCubic">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.</span>quadraticToCubic
        <span class="apidocSignatureSpan">(a, b, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quadraticToCubic = function (a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BezierPlugin.prototype" id="apidoc.module.gsap.BezierPlugin.prototype">module gsap.BezierPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.prototype._kill" id="apidoc.element.gsap.BezierPlugin.prototype._kill">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_kill
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_kill = function (lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i &#x3e; -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			a = this._autoRotate;
			if (a) {
				i = a.length;
				while (--i &#x3e; -1) {
					if (lookup[a[i][2]]) {
						a.splice(i, 1);
					}
				}
			}
			return this._super._kill.call(this, lookup);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (!vars &#x26;&#x26; !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i &#x3e; -1) {
				if (tweens[i].<span class="apidocCodeKeywordSpan">_kill</span>(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.prototype._mod" id="apidoc.element.gsap.BezierPlugin.prototype._mod">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_mod
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mod = function (lookup) {
			var op = this._overwriteProps,
				i = op.length,
				val;
			while (--i &#x3e; -1) {
				val = lookup[op[i]];
				if (val &#x26;&#x26; typeof(val) === &#x22;function&#x22;) {
					this._mod[op[i]] = val;
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			i = rp.length;
			while (--i &#x3e; -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t.<span class="apidocCodeKeywordSpan">_mod</span>(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.prototype._onInitTween" id="apidoc.element.gsap.BezierPlugin.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, vars, tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._mod = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [[&#x22;x&#x22;,&#x22;y&#x22;,&#x22;rotation&#x22;,((autoRotate === true) ?
0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i &#x3e; -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === &#x22;function&#x22;);
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf(&#x22;set&#x22;) || typeof(target[&#x22;get&#x22; + p.substr(3)]) !== &#x22;function
&#x22;) ? p : &#x22;get&#x22; + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== &#x22;cubic&#x22; &#x26;&#x26; vars.type !== &#x22;quadratic&#x22; &#x26;&#x26; vars.type !== &#x22;soft&#x22;) ? bezierThrough(values, isNaN
(vars.curviness) ? 1 : vars.curviness, false, (vars.type === &#x22;thruBasic&#x22;), vars.correlate, prepend) : _parseBezierData(values, vars
.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i &#x3e; -1) {
								for (j = 0; j &#x3c; 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === &#x22;function&#x22;) ? target[ ((p.indexOf(&#x22;set&#x22;) || typeof(target[&#x22;get&#x22; + p.substr(3)]) !== &#x22;
function&#x22;) ? p : &#x22;get&#x22; + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
								this._overwriteProps.push(p);
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always
 0 unless the tween has runBackwards:true (indicating it&#x27;s a from() tween) in which case it&#x27;s 1.
						return true;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.prototype.constructor" id="apidoc.element.gsap.BezierPlugin.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BezierPlugin.prototype.setRatio" id="apidoc.element.gsap.BezierPlugin.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.BezierPlugin.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v &#x3c; 0) ? 0 : (v &#x3e;= 1) ? segments - 1 : (segments * v) &#x3e;&#x3e; 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn&#x27;t correct)
							if (v &#x3e; this._l2 &#x26;&#x26; i &#x3c; segments - 1) {
								l = segments - 1;
								while (i &#x3c; l &#x26;&#x26; (this._l2 = lengths[++i]) &#x3c;= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v &#x3c; this._l1 &#x26;&#x26; i &#x3e; 0) {
								while (i &#x3e; 0 &#x26;&#x26; (this._l1 = lengths[--i]) &#x3e;= v) { }
								if (i === 0 &#x26;&#x26; v &#x3c; this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by &#x22;precision&#x22; and measured
 each one)
							v -= this._l1;
							i = this._si;
							if (v &#x3e; this._s2 &#x26;&#x26; i &#x3c; curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i &#x3c; l &#x26;&#x26; (this._s2 = curSeg[++i]) &#x3c;= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v &#x3c; this._s1 &#x26;&#x26; i &#x3e; 0) {
								while (i &#x3e; 0 &#x26;&#x26; (this._s1 = curSeg[--i]) &#x3e;= v) {	}
								if (i === 0 &#x26;&#x26; v &#x3c; this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i &#x3e; -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._mod[p]) {
								val = this._mod[p](val, target);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i &#x3e; -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b &#x26;&#x26; b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (this._mod[p]) {
										val = this._mod[p](val, target); //for modProps
									}

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BounceIn" id="apidoc.module.gsap.BounceIn">module gsap.BounceIn</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BounceIn.BounceIn" id="apidoc.element.gsap.BounceIn.BounceIn">
        function <span class="apidocSignatureSpan">gsap.</span>BounceIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BounceIn.prototype" id="apidoc.module.gsap.BounceIn.prototype">module gsap.BounceIn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BounceIn.prototype.constructor" id="apidoc.element.gsap.BounceIn.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.BounceIn.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BounceIn.prototype.getRatio" id="apidoc.element.gsap.BounceIn.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.BounceIn.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				if ((p = 1 - p) &#x3c; 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p &#x3c; 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p &#x3c; 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BounceInOut" id="apidoc.module.gsap.BounceInOut">module gsap.BounceInOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BounceInOut.BounceInOut" id="apidoc.element.gsap.BounceInOut.BounceInOut">
        function <span class="apidocSignatureSpan">gsap.</span>BounceInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BounceInOut.prototype" id="apidoc.module.gsap.BounceInOut.prototype">module gsap.BounceInOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BounceInOut.prototype.constructor" id="apidoc.element.gsap.BounceInOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.BounceInOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BounceInOut.prototype.getRatio" id="apidoc.element.gsap.BounceInOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.BounceInOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				var invert = (p &#x3c; 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p &#x3c; 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p &#x3c; 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p &#x3c; 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BounceOut" id="apidoc.module.gsap.BounceOut">module gsap.BounceOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BounceOut.BounceOut" id="apidoc.element.gsap.BounceOut.BounceOut">
        function <span class="apidocSignatureSpan">gsap.</span>BounceOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.BounceOut.prototype" id="apidoc.module.gsap.BounceOut.prototype">module gsap.BounceOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.BounceOut.prototype.constructor" id="apidoc.element.gsap.BounceOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.BounceOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.BounceOut.prototype.getRatio" id="apidoc.element.gsap.BounceOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.BounceOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				if (p &#x3c; 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p &#x3c; 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p &#x3c; 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CSSPlugin" id="apidoc.module.gsap.CSSPlugin">module gsap.CSSPlugin</a></h1>






    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.CSSPlugin" id="apidoc.element.gsap.CSSPlugin.CSSPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>CSSPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CSSPlugin = function () {
				TweenPlugin.call(this, &#x22;css&#x22;);
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.cascadeTo" id="apidoc.element.gsap.CSSPlugin.cascadeTo">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>cascadeTo
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cascadeTo = function (target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = TweenLite._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i &#x3e; -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.colorStringFilter" id="apidoc.element.gsap.CSSPlugin.colorStringFilter">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>colorStringFilter
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorStringFilter = function (a) {
			var combined = a[0] + a[1],
				toHSL;
			if (_colorExp.test(combined)) {
				toHSL = (combined.indexOf(&#x22;hsl(&#x22;) !== -1 || combined.indexOf(&#x22;hsla(&#x22;) !== -1);
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.getStyle" id="apidoc.element.gsap.CSSPlugin.getStyle">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>getStyle
        <span class="apidocSignatureSpan">(t, p, cs, calc, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getStyle = function (t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === &#x22;opacity&#x22;) { //several versions of IE don&#x27;t use the standard &#x22;opacity&#x22; property - they use
things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc &#x26;&#x26; t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, &#x22;-$1&#x22;).toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null &#x26;&#x26; (!rv || rv === &#x22;none&#x22; || rv === &#x22;auto&#x22; || rv === &#x22;auto auto&#x22;)) ? dflt : rv;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.parseColor" id="apidoc.element.gsap.CSSPlugin.parseColor">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>parseColor
        <span class="apidocSignatureSpan">(v, toHSL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseColor = function (v, toHSL) {
				var a, r, g, b, h, s, l, max, min, d, wasHSL;
				if (!v) {
					a = _colorLookup.black;
				} else if (typeof(v) === &#x22;number&#x22;) {
					a = [v &#x3e;&#x3e; 16, (v &#x3e;&#x3e; 8) &#x26; 255, v &#x26; 255];
				} else {
					if (v.charAt(v.length - 1) === &#x22;,&#x22;) { //sometimes a trailing comma is included and we should chop it off (typically from a
comma-delimited list of values like a textShadow:&#x22;2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)&#x22; - in this example &#x22;blue,&#x22; has a trailing
 comma. We could strip it out inside parseComplex() but we&#x27;d need to do it to the beginning and ending values plus it wouldn&#x27;t provide
 protection from other potential scenarios like if the user passes in a similar value.
						v = v.substr(0, v.length - 1);
					}
					if (_colorLookup[v]) {
						a = _colorLookup[v];
					} else if (v.charAt(0) === &#x22;#&#x22;) {
						if (v.length === 4) { //for shorthand like #9F0
							r = v.charAt(1);
							g = v.charAt(2);
							b = v.charAt(3);
							v = &#x22;#&#x22; + r + r + g + g + b + b;
						}
						v = parseInt(v.substr(1), 16);
						a = [v &#x3e;&#x3e; 16, (v &#x3e;&#x3e; 8) &#x26; 255, v &#x26; 255];
					} else if (v.substr(0, 3) === &#x22;hsl&#x22;) {
						a = wasHSL = v.match(_numExp);
						if (!toHSL) {
							h = (Number(a[0]) % 360) / 360;
							s = Number(a[1]) / 100;
							l = Number(a[2]) / 100;
							g = (l &#x3c;= 0.5) ? l * (s + 1) : l + s - l * s;
							r = l * 2 - g;
							if (a.length &#x3e; 3) {
								a[3] = Number(v[3]);
							}
							a[0] = _hue(h + 1 / 3, r, g);
							a[1] = _hue(h, r, g);
							a[2] = _hue(h - 1 / 3, r, g);
						} else if (v.indexOf(&#x22;=&#x22;) !== -1) { //if relative values are found, just return the raw strings with the relative prefixes
 in place.
							return v.match(_relNumExp);
						}
					} else {
						a = v.match(_numExp) || _colorLookup.transparent;
					}
					a[0] = Number(a[0]);
					a[1] = Number(a[1]);
					a[2] = Number(a[2]);
					if (a.length &#x3e; 3) {
						a[3] = Number(a[3]);
					}
				}
				if (toHSL &#x26;&#x26; !wasHSL) {
					r = a[0] / 255;
					g = a[1] / 255;
					b = a[2] / 255;
					max = Math.max(r, g, b);
					min = Math.min(r, g, b);
					l = (max + min) / 2;
					if (max === min) {
						h = s = 0;
					} else {
						d = max - min;
						s = l &#x3e; 0.5 ? d / (2 - max - min) : d / (max + min);
						h = (max === r) ? (g - b) / d + (g &#x3c; b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
						h *= 60;
					}
					a[0] = (h + 0.5) | 0;
					a[1] = (s * 100 + 0.5) | 0;
					a[2] = (l * 100 + 0.5) | 0;
				}
				return a;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.parseComplex" id="apidoc.element.gsap.CSSPlugin.parseComplex">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>parseComplex
        <span class="apidocSignatureSpan">(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log(&#x22;parseComplex: &#x22;+p+&#x22;, b: &#x22;+b+&#x22;, e: &#x22;+e);
				b = b || dflt || &#x22;&#x22;;
				if (typeof(e) === &#x22;function&#x22;) {
					e = e(_index, _target);
				}
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += &#x22;&#x22;; //ensures it&#x27;s a string
				if (clrs &#x26;&#x26; _colorExp.test(e + b)) { //if colors are found, normalize the formatting to rgba() or hsla().
					e = [b, e];
					CSSPlugin.colorStringFilter(e);
					b = e[0];
					e = e[1];
				}
				var ba = b.split(&#x22;, &#x22;).join(&#x22;,&#x22;).split(&#x22; &#x22;), //beginning array
					ea = e.split(&#x22;, &#x22;).join(&#x22;,&#x22;).split(&#x22; &#x22;), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
				if (e.indexOf(&#x22;,&#x22;) !== -1 || b.indexOf(&#x22;,&#x22;) !== -1) {
					ba = ba.join(&#x22; &#x22;).replace(_commasOutsideParenExp, &#x22;, &#x22;).split(&#x22; &#x22;);
					ea = ea.join(&#x22; &#x22;).replace(_commasOutsideParenExp, &#x22;, &#x22;).split(&#x22; &#x22;);
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log(&#x22;mismatched formatting detected on &#x22; + p + &#x22; (&#x22; + b + &#x22; vs &#x22; + e + &#x22;)&#x22;);
					ba = (dflt || &#x22;&#x22;).split(&#x22; &#x22;);
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				_colorExp.lastIndex = 0;
				for (i = 0; i &#x3c; l; i++) {
					bv = ba[i];
					ev = ea[i];
					bn = parseFloat(bv);
					//if the value begins with a number (most common). It&#x27;s fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra(&#x22;&#x22;, bn, _parseChange(ev, bn), ev.replace(_relNumExp, &#x22;&#x22;), (autoRound &#x26;&#x26; ev.indexOf(&#x22;px&#x22;) !== -1), true);

					//if the value is a color
					} else if (clrs &#x26;&#x26; _colorExp.test(bv)) {
						str = ev.indexOf(&#x22;)&#x22;) + 1;
						str = &#x22;)&#x22; + (str ? ev.substr(str) : &#x22;&#x22;); //if there&#x27;s a comma or ) at the end, retain it.
						useHSL = (ev.indexOf(&#x22;hsl&#x22;) !== -1 &#x26;&#x26; _supportsOpacity);
						bv = _parseColor(bv, useHSL);
						ev = _parseColor(ev, useHSL);
						hasAlpha = (bv.length + ev.length &#x3e; 6);
						if (hasAlpha &#x26;&#x26; !_supportsOpacity &#x26;&#x26; ev[3] === 0) { //older versions of IE don&#x27;t support rgba(), so if the destination alpha
 is 0, just use &#x22;transparent&#x22; for the end color
							pt[&#x22;xs&#x22; + pt.l] += pt.l ? &#x22; transparent&#x22; : &#x22;transparent&#x22;;
							pt.e = pt.e.split(ea[i]).join(&#x22;transparent&#x22;);
						} else {
							if (!_supportsOpacity) { //old versions of IE don&#x27;t support rgba().
								hasAlpha = false;
							}
							if (useHSL) {
								pt.appendXtra((hasAlpha ? &#x22;hsla(&#x22; : &#x22;hsl(&#x22;), bv[0], _parseChange(ev[0], bv[0]), &#x22;,&#x22;, false, true)
									.appendXtra(&#x22;&#x22;, bv[1], _parseChange(ev[1], bv[1]), &#x22;%,&#x22;, false)
									.appendXtra(&#x22;&#x22;, bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? &#x22;%,&#x22; : &#x22;%&#x22; + str), false);
							} else {
								pt.appendXtra((hasAlpha ? &#x22;rgba(&#x22; : &#x22;rgb(&#x22;), bv[0], ev[0] - bv[0], &#x22;,&#x22;, true, true)
									.appendXtra(&#x22;&#x22;, bv[1], ev[1] - bv[1], &#x22;,&#x22;, true)
									.appendXtra(&#x22;&#x22;, bv[2], ev[2] - bv[2], (hasAlpha ? &#x22;,&#x22; : str), true);
							}

							if (hasAlpha) {
								bv = (bv.length &#x3c; 4) ? 1 : bv[3];
								pt.appendXtra(&#x22;&#x22;, bv, ((ev.length &#x3c; 4) ? 1 : ev[3]) - bv, str, false);
							}
						}
						_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt[&#x22;xs&#x22; + pt.l] += (pt.l || pt[&#x22;xs&#x22; + pt.l]) ? &#x22; &#x22; + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative
 values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log(&#x22;mismatched formatting detected on &#x22; + p + &#x22; (&#x22; + b + &#x22; vs &#x22; + e + &#x22;)&#x22;);
								return pt;
							}
							ni = 0;
							for (xi = 0 ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.registerSpecialProp" id="apidoc.element.gsap.CSSPlugin.registerSpecialProp">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.</span>registerSpecialProp
        <span class="apidocSignatureSpan">(name, onInitTween, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerSpecialProp = function (name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CSSPlugin._internals" id="apidoc.module.gsap.CSSPlugin._internals">module gsap.CSSPlugin._internals</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.CSSPropTween" id="apidoc.element.gsap.CSSPlugin._internals.CSSPropTween">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>CSSPropTween
        <span class="apidocSignatureSpan">(t, p, s, c, next, type, n, r, pr, b, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting
 looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = r; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target&#x27;s property, like
 tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.Transform" id="apidoc.element.gsap.CSSPlugin._internals.Transform">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>Transform
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Transform = function () {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || &#x22;auto&#x22;;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals._parseToProxy" id="apidoc.element.gsap.CSSPlugin._internals._parseToProxy">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_parseToProxy
        <span class="apidocSignatureSpan">(t, vars, cssp, pt, plugin, shallow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt &#x26;&#x26; pt !== bpt) {
					if (pt.type &#x3c;= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, &#x22;s&#x22;, p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i &#x3e; 0) {
								xp = &#x22;xn&#x22; + i;
								p = pt.p + &#x22;_&#x22; + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals._registerComplexSpecialProp" id="apidoc.element.gsap.CSSPlugin._internals._registerComplexSpecialProp">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_registerComplexSpecialProp
        <span class="apidocSignatureSpan">(p, options, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_registerComplexSpecialProp = function (p, options, defaults) {
				if (typeof(options) !== &#x22;object&#x22;) {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(&#x22;,&#x22;),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i &#x3c; a.length; i++) {
					options.prefix = (i === 0 &#x26;&#x26; options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals._registerPluginProp" id="apidoc.element.gsap.CSSPlugin._internals._registerPluginProp">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_registerPluginProp
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_registerPluginProp = function (p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + &#x22;Plugin&#x22;;
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log(&#x22;Error: &#x22; + pluginName + &#x22; js file not loaded.&#x22;);
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals._setPluginRatio" id="apidoc.element.gsap.CSSPlugin._internals._setPluginRatio">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>_setPluginRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setPluginRatio = function (v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str, p;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = Math.round(val);
					} else if (val &#x3c; min &#x26;&#x26; val &#x3e; -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = d.mod ? d.mod(proxy.rotation, this.t) : proxy.rotation; //special case for ModifyPlugin to hook into
 an auto-rotating bezier
				}
				//at the end, we must set the CSSPropTween&#x27;s &#x22;e&#x22; (end) value dynamically here because that&#x27;s what is used in the final setRatio
() method. Same for &#x22;b&#x22; at the beginning.
				if (v === 1 || v === 0) {
					mpt = d.firstMPT;
					p = (v === 1) ? &#x22;e&#x22; : &#x22;b&#x22;;
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt[p] = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i &#x3c; pt.l; i++) {
								str += pt[&#x22;xn&#x22;+i] + pt[&#x22;xs&#x22;+(i+1)];
							}
							pt[p] = str;
						}
						mpt = mpt._next;
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.calculateOffset" id="apidoc.element.gsap.CSSPlugin._internals.calculateOffset">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>calculateOffset
        <span class="apidocSignatureSpan">(t, p, cs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateOffset = function (t, p, cs) { //for figuring out &#x22;top&#x22; or &#x22;left&#x22; in px when it&#x27;s &#x22;auto&#x22;. We need to factor in margin with the offsetLeft
/offsetTop
				if (_getStyle(t, &#x22;position&#x22;, cs) !== &#x22;absolute&#x22;) { return 0; }
				var dim = ((p === &#x22;left&#x22;) ? &#x22;Left&#x22; : &#x22;Top&#x22;),
					v = _getStyle(t, &#x22;margin&#x22; + dim, cs);
				return t[&#x22;offset&#x22; + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, &#x22;&#x22;)) || 0);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.convertToPixels" id="apidoc.element.gsap.CSSPlugin._internals.convertToPixels">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>convertToPixels
        <span class="apidocSignatureSpan">(t, p, v, sfx, recurse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">convertToPixels = function (t, p, v, sfx, recurse) {
				if (sfx === &#x22;px&#x22; || !sfx) { return v; }
				if (sfx === &#x22;auto&#x22; || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v &#x3c; 0),
					precise = (v === 1),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (precise) {
					v *= 100;
				}
				if (sfx === &#x22;%&#x22; &#x26;&#x26; p.indexOf(&#x22;border&#x22;) !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = &#x22;border:0 solid red;position:&#x22; + _getStyle(t, &#x22;position&#x22;) + &#x22;;line-height:0;&#x22;;
					if (sfx === &#x22;%&#x22; || !node.appendChild || sfx.charAt(0) === &#x22;v&#x22; || sfx === &#x22;rem&#x22;) {
						node = t.parentNode || _doc.body;
						cache = node._gsCache;
						time = TweenLite.ticker.frame;
						if (cache &#x26;&#x26; horiz &#x26;&#x26; cache.time === time) { //performance optimization: we record the width of elements along with the ticker
 frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn&#x27;t change on the same tick
)
							return cache.width * v / 100;
						}
						style[(horiz ? &#x22;width&#x22; : &#x22;height&#x22;)] = v + sfx;
					} else {
						style[(horiz ? &#x22;borderLeftWidth&#x22; : &#x22;borderTopWidth&#x22;)] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? &#x22;offsetWidth&#x22; : &#x22;offsetHeight&#x22;)]);
					node.removeChild(_tempDiv);
					if (horiz &#x26;&#x26; sfx === &#x22;%&#x22; &#x26;&#x26; CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 &#x26;&#x26; !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				if (precise) {
					pix /= 100;
				}
				return neg ? -pix : pix;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.getTransform" id="apidoc.element.gsap.CSSPlugin._internals.getTransform">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>getTransform
        <span class="apidocSignatureSpan">(t, cs, rec, parse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransform = function (t, cs, rec, parse) {
				if (t._gsTransform &#x26;&#x26; rec &#x26;&#x26; !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don&#x27;t accurately return the
 calculated style for the transform (particularly for SVG), so it&#x27;s almost always safest to just use the values we&#x27;ve already applied
 rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX &#x3c; 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously
 so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY
 and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being
 the user&#x27;s intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, &#x22;0 0 0&#x22;).split(&#x22; &#x22;)[2]) || tm.zOrigin  ||
0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					m, i, scaleX, scaleY, rotation, skewX;

				tm.svg = !!(t.getCTM &#x26;&#x26; _isSVG(t));
				if (tm.svg) {
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, &#x22;50% 50%&#x22;) + &#x22;&#x22;, tm, t.getAttribute(&#x22;data-svg-origin&#x22;));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
				}
				m = _getMatrix(t);
				if (m !== _identity2DMatrix) {

					if (m.length === 16) {
						//we&#x27;ll only look at these position-related 6 variables first because if x/y/z all match, it&#x27;s relatively safe to assume we
 don&#x27;t need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would
 look the same as rotation:180 - there&#x27;s no way to know for sure which direction was taken based solely on the matrix3d() values
)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;

						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(-a31, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							a11 = a11*cos+a12*sin;
							t2 = a21*cos+a22*sin;
							a22 = a21*-sin+a22*cos;
							a32 = a31*-sin+a32*cos;
							a21 = t2;
						}

						if (tm.rotationX &#x26;&#x26; Math.abs(tm.rotationX) + Math.abs(tm.rotation) &#x3e; 359.9) { //when rotationY is set, it will often be parsed
 as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that
 here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY = 180 - tm.rotationY;
						}

						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.set3DTransformRatio" id="apidoc.element.gsap.CSSPlugin._internals.set3DTransformRatio">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>set3DTransformRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set3DTransformRatio = function (v) {
				var t = this.data, //refers to the element&#x27;s _gsTransform object
					style = this.t.style,
					angle = t.rotation,
					rotationX = t.rotationX,
					rotationY = t.rotationY,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					isSVG = t.svg,
					perspective = t.perspective,
					force3D = t.force3D,
					skewY = t.skewY,
					skewX = t.skewX,
					t1,	a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
				if (skewY) { //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees
 looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
					skewX += skewY;
					angle += skewY;
				}

				//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
				if (((((v === 1 || v === 0) &#x26;&#x26; force3D === &#x22;auto&#x22; &#x26;&#x26; (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime
)) || !force3D) &#x26;&#x26; !z &#x26;&#x26; !perspective &#x26;&#x26; !rotationY &#x26;&#x26; !rotationX &#x26;&#x26; sz === 1) || (_useSVGTransformAttr &#x26;&#x26; isSVG) || !_supports3D
) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve
 performance especially on mobile devices. Check the tween&#x27;s totalTime/totalDuration too in order to make sure it doesn&#x27;t happen
 between repeats if it&#x27;s a repeating tween.

					//2D
					if (angle || skewX || isSVG) {
						angle *= _DEG2RAD;
						skew = skewX * _DEG2RAD;
						rnd = 100000;
						a11 = Math.cos(angle) * sx;
						a21 = Math.sin(angle) * sx;
						a12 = Math.sin(angle - skew) * -sy;
						a22 = Math.cos(angle - skew) * sy;
						if (skew &#x26;&#x26; t.skewType === &#x22;simple&#x22;) { //by default, we compensate skewing on the other axis to make it look more natural,
but you can set the skewType to &#x22;simple&#x22; to use the uncompensated skewing that CSS does
							t1 = Math.tan(skew - skewY * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							a12 *= t1;
							a22 *= t1;
							if (skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
						if (isSVG) {
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
							if (_useSVGTransformAttr &#x26;&#x26; (t.xPercent || t.yPercent)) { //The SVG spec doesn&#x27;t support percentage-based translation in
the &#x22;transform&#x22; attribute, so we merge it into the matrix to simulate it.
								min = this.t.getBBox();
								x += t.xPercent * 0.01 * min.width;
								y += t.yPercent * 0.01 * min.height;
							}
							min = 0.000001;
							if (x &#x3c; min) if (x &#x3e; -min) {
								x = 0;
							}
							if (y &#x3c; min) if (y &#x3e; -min) {
								y = 0;
							}
						}
						transform = (((a11 * rnd) | 0) / rnd) + &#x22;,&#x22; + (((a21 * rnd) | 0) / rnd) + &#x22;,&#x22; + (((a12 * rnd) | 0) / rnd) + &#x22;,&#x22; + (((a22 *
rnd) | 0) / rnd) + &#x22;,&#x22; + x + &#x22;,&#x22; + y + &#x22;)&#x22;;
						if (isSVG &#x26;&#x26; _useSVGTransformAttr) {
							this.t.setAttribute(&#x22;transform&#x22;, &#x22;matrix(&#x22; + transform);
						} else {
							//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the &#x22;e-&#x22; towards the end) and
 would render the object slightly off. So we round to 5 decimal places.
							style[_transformProp] = ((t.xPercent || t.yPercent) ? &#x22;translate(&#x22; + t.xPercent + &#x22;%,&#x22; + t.yPercent + &#x22;%) matrix(&#x22; : &#x22;matrix
(&#x22;) + transform;
						}
					} else {
						style[_transformProp] = ((t.xPercent || t.yPercent) ? &#x22;translate(&#x22; + t.xPercent + &#x22;%,&#x22; + t.yPercent + &#x22;%) matrix(&#x22; : &#x22;matrix
(&#x22;) + sx + &#x22;,0,0,&#x22; + sy + &#x22;,&#x22; + x + &#x22;,&#x22; + y + &#x22;)&#x22;;
					}
					return;

				}
				if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as
 black when displayed inside an iframe and the 3D scale is very small and doesn&#x27;t change sufficiently enough between renders (like
 if you use a Power4.easeInOut to scale from 0 to 1 whe ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.setTransformRatio" id="apidoc.element.gsap.CSSPlugin._internals.setTransformRatio">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.</span>setTransformRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTransformRatio = function (v) {
				var t = this.data, //refers to the element&#x27;s _gsTransform object
					style = this.t.style,
					angle = t.rotation,
					rotationX = t.rotationX,
					rotationY = t.rotationY,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					isSVG = t.svg,
					perspective = t.perspective,
					force3D = t.force3D,
					skewY = t.skewY,
					skewX = t.skewX,
					t1,	a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
				if (skewY) { //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees
 looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
					skewX += skewY;
					angle += skewY;
				}

				//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
				if (((((v === 1 || v === 0) &#x26;&#x26; force3D === &#x22;auto&#x22; &#x26;&#x26; (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime
)) || !force3D) &#x26;&#x26; !z &#x26;&#x26; !perspective &#x26;&#x26; !rotationY &#x26;&#x26; !rotationX &#x26;&#x26; sz === 1) || (_useSVGTransformAttr &#x26;&#x26; isSVG) || !_supports3D
) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve
 performance especially on mobile devices. Check the tween&#x27;s totalTime/totalDuration too in order to make sure it doesn&#x27;t happen
 between repeats if it&#x27;s a repeating tween.

					//2D
					if (angle || skewX || isSVG) {
						angle *= _DEG2RAD;
						skew = skewX * _DEG2RAD;
						rnd = 100000;
						a11 = Math.cos(angle) * sx;
						a21 = Math.sin(angle) * sx;
						a12 = Math.sin(angle - skew) * -sy;
						a22 = Math.cos(angle - skew) * sy;
						if (skew &#x26;&#x26; t.skewType === &#x22;simple&#x22;) { //by default, we compensate skewing on the other axis to make it look more natural,
but you can set the skewType to &#x22;simple&#x22; to use the uncompensated skewing that CSS does
							t1 = Math.tan(skew - skewY * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							a12 *= t1;
							a22 *= t1;
							if (skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
						if (isSVG) {
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
							if (_useSVGTransformAttr &#x26;&#x26; (t.xPercent || t.yPercent)) { //The SVG spec doesn&#x27;t support percentage-based translation in
the &#x22;transform&#x22; attribute, so we merge it into the matrix to simulate it.
								min = this.t.getBBox();
								x += t.xPercent * 0.01 * min.width;
								y += t.yPercent * 0.01 * min.height;
							}
							min = 0.000001;
							if (x &#x3c; min) if (x &#x3e; -min) {
								x = 0;
							}
							if (y &#x3c; min) if (y &#x3e; -min) {
								y = 0;
							}
						}
						transform = (((a11 * rnd) | 0) / rnd) + &#x22;,&#x22; + (((a21 * rnd) | 0) / rnd) + &#x22;,&#x22; + (((a12 * rnd) | 0) / rnd) + &#x22;,&#x22; + (((a22 *
rnd) | 0) / rnd) + &#x22;,&#x22; + x + &#x22;,&#x22; + y + &#x22;)&#x22;;
						if (isSVG &#x26;&#x26; _useSVGTransformAttr) {
							this.t.setAttribute(&#x22;transform&#x22;, &#x22;matrix(&#x22; + transform);
						} else {
							//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the &#x22;e-&#x22; towards the end) and
 would render the object slightly off. So we round to 5 decimal places.
							style[_transformProp] = ((t.xPercent || t.yPercent) ? &#x22;translate(&#x22; + t.xPercent + &#x22;%,&#x22; + t.yPercent + &#x22;%) matrix(&#x22; : &#x22;matrix
(&#x22;) + transform;
						}
					} else {
						style[_transformProp] = ((t.xPercent || t.yPercent) ? &#x22;translate(&#x22; + t.xPercent + &#x22;%,&#x22; + t.yPercent + &#x22;%) matrix(&#x22; : &#x22;matrix
(&#x22;) + sx + &#x22;,0,0,&#x22; + sy + &#x22;,&#x22; + x + &#x22;,&#x22; + y + &#x22;)&#x22;;
					}
					return;

				}
				if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as
 black when displayed inside an iframe and the 3D scale is very small and doesn&#x27;t change sufficiently enough between renders (like
 if you use a Power4.easeInOut to scale from 0 to 1 whe ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CSSPlugin._internals.CSSPropTween.prototype" id="apidoc.module.gsap.CSSPlugin._internals.CSSPropTween.prototype">module gsap.CSSPlugin._internals.CSSPropTween.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin._internals.CSSPropTween.prototype.appendXtra" id="apidoc.element.gsap.CSSPlugin._internals.CSSPropTween.prototype.appendXtra">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin._internals.CSSPropTween.prototype.</span>appendXtra
        <span class="apidocSignatureSpan">(pfx, s, c, sfx, r, pad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendXtra = function (pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt[&#x22;xs&#x22; + l] += (pad &#x26;&#x26; (l || pt[&#x22;xs&#x22; + l])) ? &#x22; &#x22; + pfx : pfx || &#x22;&#x22;;
			if (!c) if (l !== 0 &#x26;&#x26; !pt.plugin) { //typically we&#x27;ll combine non-changing values right into the xs to optimize performance,
but we don&#x27;t combine them when there&#x27;s a plugin that will be tweening the values because it may depend on the values being split
 apart, like for a bezier, if a value doesn&#x27;t change between the first and second iteration but then it does on the 3rd, we&#x27;ll run
 into trouble because there&#x27;s no xn slot for that value!
				pt[&#x22;xs&#x22; + l] += s + (sfx || &#x22;&#x22;);
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt[&#x22;xs&#x22; + pt.l] = sfx || &#x22;&#x22;;
			if (l &#x3e; 0) {
				pt.data[&#x22;xn&#x22; + l] = s + c;
				pt.rxp[&#x22;xn&#x22; + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt[&#x22;xn&#x22; + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, &#x22;xn&#x22; + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember
, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is &#x22;&#x22; (the default), it&#x27;ll cast the end value as a string
. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing
things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CSSPlugin.prototype" id="apidoc.module.gsap.CSSPlugin.prototype">module gsap.CSSPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype._addLazySet" id="apidoc.element.gsap.CSSPlugin.prototype._addLazySet">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_addLazySet
        <span class="apidocSignatureSpan">(t, p, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addLazySet = function (t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype._enableTransforms" id="apidoc.element.gsap.CSSPlugin.prototype._enableTransforms">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_enableTransforms
        <span class="apidocSignatureSpan">(threeD)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_enableTransforms = function (threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property
 with the appropriate values.
			this._transformType = (!(this._transform.svg &#x26;&#x26; _useSVGTransformAttr) &#x26;&#x26; (threeD || this._transformType === 3)) ? 3 : 2;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype._kill" id="apidoc.element.gsap.CSSPlugin.prototype._kill">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_kill
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_kill = function (lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we&#x27;re not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className &#x26;&#x26; (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too;
a linked list starts at the className&#x27;s &#x22;xfirst&#x22;.
				xfirst = pt.xfirst;
				if (xfirst &#x26;&#x26; xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.plugin &#x26;&#x26; pt.plugin !== p &#x26;&#x26; pt.plugin._kill) { //for plugins that are registered with CSSPlugin, we should notify them
 of the kill.
					pt.plugin._kill(lookup);
					p = pt.plugin;
				}
				pt = pt._next;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (!vars &#x26;&#x26; !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i &#x3e; -1) {
				if (tweens[i].<span class="apidocCodeKeywordSpan">_kill</span>(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype._linkCSSP" id="apidoc.element.gsap.CSSPlugin.prototype._linkCSSP">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_linkCSSP
        <span class="apidocSignatureSpan">(pt, next, prev, remove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_linkCSSP = function (pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove &#x26;&#x26; this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype._mod" id="apidoc.element.gsap.CSSPlugin.prototype._mod">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_mod
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mod = function (lookup) {
			var pt = this._firstPT;
			while (pt) {
				if (typeof(lookup[pt.p]) === &#x22;function&#x22; &#x26;&#x26; lookup[pt.p] === Math.round) { //only gets called by RoundPropsPlugin (ModifyPlugin
 manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently
 in this plugin for performance reasons, leveraging &#x22;r&#x22; as an indicator that the value should be rounded internally..
					pt.r = 1;
				}
				pt = pt._next;
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			i = rp.length;
			while (--i &#x3e; -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t.<span class="apidocCodeKeywordSpan">_mod</span>(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype._onInitTween" id="apidoc.element.gsap.CSSPlugin.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, vars, tween, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, vars, tween, index) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = _target = target;
			this._tween = tween;
			this._vars = vars;
			_index = index;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, &#x22;&#x22;);
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === &#x22;&#x22;) {
				v = _getStyle(target, &#x22;zIndex&#x22;, _cs);
				if (v === &#x22;auto&#x22; || v === &#x22;&#x22;) {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don&#x27;t have
 a zIndex set. We also can&#x27;t just apply this inside _parseTransform() because anything that&#x27;s moved in any way (like using &#x22;left
&#x22; or &#x22;top&#x22; instead of transforms like &#x22;x&#x22; and &#x22;y&#x22;) can be affected, so it is best to ensure that anything that&#x27;s tweening has a
z-index. Setting &#x22;WebkitPerspective&#x22; to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus
 zIndex is less memory-intensive.
					this._addLazySet(style, &#x22;zIndex&#x22;, 0);
				}
			}

			if (typeof(vars) === &#x22;string&#x22;) {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + &#x22;;&#x22; + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity &#x26;&#x26; _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in,
so {className:&#x22;myClass&#x22;, scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, &#x22;className&#x22;, this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn&#x27;t set, iOS Safari doesn&#x27;t repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === &#x22;&#x22;) {
						zIndex = _getStyle(target, &#x22;zIndex&#x22;, _cs);
						if (zIndex === &#x22;auto&#x22; || zIndex === &#x22;&#x22;) {
							this._addLazySet(style, &#x22;zIndex&#x22;, 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to &#x22;top&#x22; and &#x22;left&#x22; that are made on the same frame/render as a transform
 update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting &#x22;WebkitPerspective&#x22; to a non-zero value
 worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the
 edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, &#x22;WebkitBackfaceVisibility&#x22;, this._vars.WebkitBackfaceVisibility || (threeD ? &#x22;visible&#x22; : &#x22;hidden&#x22;));
					}
				}
				pt2 = pt;
				while (pt2 &#x26;&#x26; pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, &#x22;transform&#x22;, 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don&#x27;t want to force the overwrite of all &#x22;transform&#x22; tweens of the target - we only care about individual
 transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps
 which is why we need to pop() here.
			}

			if (_has ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype.constructor" id="apidoc.element.gsap.CSSPlugin.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
				TweenPlugin.call(this, &#x22;css&#x22;);
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype.parse" id="apidoc.element.gsap.CSSPlugin.prototype.parse">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>parse
        <span class="apidocSignatureSpan">(target, vars, pt, plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				if (typeof(es) === &#x22;function&#x22;) {
					es = es(_index, _target);
				}
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);

				} else {
					bs = _getStyle(target, p, _cs) + &#x22;&#x22;;
					isStr = (typeof(es) === &#x22;string&#x22;);
					if (p === &#x22;color&#x22; || p === &#x22;fill&#x22; || p === &#x22;stroke&#x22; || p.indexOf(&#x22;Color&#x22;) !== -1 || (isStr &#x26;&#x26; _rgbhslExp.test(es))) { //Opera
 uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length &#x3e; 3) ? &#x22;rgba(&#x22; : &#x22;rgb(&#x22;) + es.join(&#x22;,&#x22;) + &#x22;)&#x22;;
						}
						pt = _parseComplex(style, p, bs, es, true, &#x22;transparent&#x22;, pt, 0, plugin);

					} else if (isStr &#x26;&#x26; _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + &#x22;&#x22;).length) : &#x22;&#x22;; //remember, bs could be non-numeric like &#x22;normal&#x22; for fontWeight
, so we should default to a blank suffix in that case.

						if (bs === &#x22;&#x22; || bs === &#x22;auto&#x22;) {
							if (p === &#x22;width&#x22; || p === &#x22;height&#x22;) {
								bn = _getDimension(target, p, _cs);
								bsfx = &#x22;px&#x22;;
							} else if (p === &#x22;left&#x22; || p === &#x22;top&#x22;) {
								bn = _calculateOffset(target, p, _cs);
								bsfx = &#x22;px&#x22;;
							} else {
								bn = (p !== &#x22;opacity&#x22;) ? 0 : 1;
								bsfx = &#x22;&#x22;;
							}
						}

						rel = (isStr &#x26;&#x26; es.charAt(1) === &#x22;=&#x22;);
						if (rel) {
							en = parseInt(es.charAt(0) + &#x22;1&#x22;, 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, &#x22;&#x22;);
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, &#x22;&#x22;) : &#x22;&#x22;;
						}

						if (esfx === &#x22;&#x22;) {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found,
use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record
 the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn
&#x27;t match the beginning value&#x27;s suffix.

						//if the beginning/ending suffixes don&#x27;t match, normalize them...
						if (bsfx !== esfx) if (esfx !== &#x22;&#x22;) if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don&#x27;t need
to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === &#x22;%&#x22;) {
								bn /= _convertToPixels(target, p, 100, &#x22;%&#x22;) / 100;
								if (vars.strictUnits !== true) { //some browsers report only &#x22;px&#x22; values instead of allowing &#x22;%&#x22; with getComputedStyle(),
so we assume that if we&#x27;re tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly
 useful for responsive designs that use from() tweens.
									bs = bn + &#x22;%&#x22;;
								}

							} else if (esfx === &#x22;em&#x22; || esfx === &#x22;rem&#x22; || esfx === &#x22;vw&#x22; || esfx === &#x22;vh&#x22;) {
								bn /= _convertToPixels(target, p, 1, esfx);

							//otherwise convert to pixels.
							} else if (esfx !== &#x22;px&#x22;) {
								en = _convertToPixels(target, p, en, esfx);
								esfx = &#x22;px&#x22;; //we don&#x27;t use bsfx after this, so we don&#x27;t need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) &#x26;&#x26; (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn&#x27;t
 really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need
 to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points
: [{left:50},{le ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSPlugin.prototype.setRatio" id="apidoc.element.gsap.CSSPlugin.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.CSSPlugin.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like &#x22;position
&#x22; or &#x22;float&#x22; or whatever) are set and so that if the beginning/ending suffixes (units) didn&#x27;t match and we normalized to px, the
 value that the user passed in is used here. We check to see if the tween is at its beginning in case it&#x27;s a from() tween in which
 case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 &#x26;&#x26; (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r &#x26;&#x26; pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like &#x22;rect(5px,10px
,20px,25px)&#x22;
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i &#x3c; pt.l; i++) {
									str += pt[&#x22;xn&#x22;+i] + pt[&#x22;xs&#x22;+(i+1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.
000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val &#x3c; min) if (val &#x3e; -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like &#x22;rect(5px,10px,20px
,25px)&#x22;
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i &#x3c; pt.l; i++) {
								str += pt[&#x22;xn&#x22;+i] + pt[&#x22;xs&#x22;+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different
 units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CSSRulePlugin" id="apidoc.module.gsap.CSSRulePlugin">module gsap.CSSRulePlugin</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CSSRulePlugin.CSSRulePlugin" id="apidoc.element.gsap.CSSRulePlugin.CSSRulePlugin">
        function <span class="apidocSignatureSpan">gsap.</span>CSSRulePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CSSRulePlugin = function () {
				TweenPlugin.call(this, &#x22;cssRule&#x22;);
				this._overwriteProps.length = 0;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSRulePlugin.getRule" id="apidoc.element.gsap.CSSRulePlugin.getRule">
        function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.</span>getRule
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRule = function (selector) {
			var ruleProp = _doc.all ? &#x27;rules&#x27; : &#x27;cssRules&#x27;,
				ss = _doc.styleSheets,
				i = ss.length,
				pseudo = (selector.charAt(0) === &#x22;:&#x22;),
				j, curSS, cs, a;
			selector = (pseudo ? &#x22;&#x22; : &#x22;,&#x22;) + selector.toLowerCase() + &#x22;,&#x22;; //note: old versions of IE report tag name selectors as upper
case, so we just change everything to lowercase.
			if (pseudo) {
				a = [];
			}
			while (--i &#x3e; -1) {
				//Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.
				try {
					curSS = ss[i][ruleProp];
					if (!curSS) {
						continue;
					}
					j = curSS.length;
				} catch (e) {
					console.log(e);
					continue;
				}
				while (--j &#x3e; -1) {
					cs = curSS[j];
					if (cs.selectorText &#x26;&#x26; (&#x22;,&#x22; + cs.selectorText.split(&#x22;::&#x22;).join(&#x22;:&#x22;).toLowerCase() + &#x22;,&#x22;).indexOf(selector) !== -1) { //note
: IE adds an extra &#x22;:&#x22; to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.
						if (pseudo) {
							a.push(cs.style);
						} else {
							return cs.style;
						}
					}
				}
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CSSRulePlugin.prototype" id="apidoc.module.gsap.CSSRulePlugin.prototype">module gsap.CSSRulePlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CSSRulePlugin.prototype._onInitTween" id="apidoc.element.gsap.CSSRulePlugin.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween) {
			if (target.cssText === undefined) {
				return false;
			}
			var div = target._gsProxy = target._gsProxy || _doc.createElement(&#x22;div&#x22;);
			this._ss = target;
			this._proxy = div.style;
			div.style.cssText = target.cssText;
			CSSPlugin.prototype._onInitTween.call(this, div, value, tween); //we just offload all the work to the regular CSSPlugin and then
 copy the cssText back over to the rule in the setRatio() method. This allows us to have all of the updates to CSSPlugin automatically
 flow through to CSSRulePlugin instead of having to maintain both
			return true;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSRulePlugin.prototype.constructor" id="apidoc.element.gsap.CSSRulePlugin.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
				TweenPlugin.call(this, &#x22;cssRule&#x22;);
				this._overwriteProps.length = 0;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CSSRulePlugin.prototype.setRatio" id="apidoc.element.gsap.CSSRulePlugin.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.CSSRulePlugin.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (v) {
			_superSetRatio.call(this, v);
			this._ss.cssText = this._proxy.cssText;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CircIn" id="apidoc.module.gsap.CircIn">module gsap.CircIn</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CircIn.CircIn" id="apidoc.element.gsap.CircIn.CircIn">
        function <span class="apidocSignatureSpan">gsap.</span>CircIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CircIn.prototype" id="apidoc.module.gsap.CircIn.prototype">module gsap.CircIn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CircIn.prototype.constructor" id="apidoc.element.gsap.CircIn.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.CircIn.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CircIn.prototype.getRatio" id="apidoc.element.gsap.CircIn.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.CircIn.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CircInOut" id="apidoc.module.gsap.CircInOut">module gsap.CircInOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CircInOut.CircInOut" id="apidoc.element.gsap.CircInOut.CircInOut">
        function <span class="apidocSignatureSpan">gsap.</span>CircInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CircInOut.prototype" id="apidoc.module.gsap.CircInOut.prototype">module gsap.CircInOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CircInOut.prototype.constructor" id="apidoc.element.gsap.CircInOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.CircInOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CircInOut.prototype.getRatio" id="apidoc.element.gsap.CircInOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.CircInOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return ((p*=2) &#x3c; 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CircOut" id="apidoc.module.gsap.CircOut">module gsap.CircOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CircOut.CircOut" id="apidoc.element.gsap.CircOut.CircOut">
        function <span class="apidocSignatureSpan">gsap.</span>CircOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.CircOut.prototype" id="apidoc.module.gsap.CircOut.prototype">module gsap.CircOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.CircOut.prototype.constructor" id="apidoc.element.gsap.CircOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.CircOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.CircOut.prototype.getRatio" id="apidoc.element.gsap.CircOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.CircOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ColorPropsPlugin" id="apidoc.module.gsap.ColorPropsPlugin">module gsap.ColorPropsPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin.ColorPropsPlugin" id="apidoc.element.gsap.ColorPropsPlugin.ColorPropsPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>ColorPropsPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ColorPropsPlugin = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin.colorStringFilter" id="apidoc.element.gsap.ColorPropsPlugin.colorStringFilter">
        function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.</span>colorStringFilter
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorStringFilter = function (a) {
		var combined = a[0] + a[1],
			toHSL;
		_colorExp.lastIndex = 0;
		if (_colorExp.test(combined)) {
			toHSL = (combined.indexOf(&#x22;hsl(&#x22;) !== -1 || combined.indexOf(&#x22;hsla(&#x22;) !== -1);
			a[0] = _formatColors(a[0], toHSL);
			a[1] = _formatColors(a[1], toHSL);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin.parseColor" id="apidoc.element.gsap.ColorPropsPlugin.parseColor">
        function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.</span>parseColor
        <span class="apidocSignatureSpan">(v, toHSL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseColor = function (v, toHSL) {
			var a, r, g, b, h, s, l, max, min, d, wasHSL;
			if (!v) {
				a = _colorLookup.black;
			} else if (typeof(v) === &#x22;number&#x22;) {
				a = [v &#x3e;&#x3e; 16, (v &#x3e;&#x3e; 8) &#x26; 255, v &#x26; 255];
			} else {
				if (v.charAt(v.length - 1) === &#x22;,&#x22;) { //sometimes a trailing comma is included and we should chop it off (typically from a comma
-delimited list of values like a textShadow:&#x22;2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)&#x22; - in this example &#x22;blue,&#x22; has a trailing
 comma. We could strip it out inside parseComplex() but we&#x27;d need to do it to the beginning and ending values plus it wouldn&#x27;t provide
 protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					a = _colorLookup[v];
				} else if (v.charAt(0) === &#x22;#&#x22;) {
					if (v.length === 4) { //for shorthand like #9F0
						r = v.charAt(1);
						g = v.charAt(2);
						b = v.charAt(3);
						v = &#x22;#&#x22; + r + r + g + g + b + b;
					}
					v = parseInt(v.substr(1), 16);
					a = [v &#x3e;&#x3e; 16, (v &#x3e;&#x3e; 8) &#x26; 255, v &#x26; 255];
				} else if (v.substr(0, 3) === &#x22;hsl&#x22;) {
					a = wasHSL = v.match(_numExp);
					if (!toHSL) {
						h = (Number(a[0]) % 360) / 360;
						s = Number(a[1]) / 100;
						l = Number(a[2]) / 100;
						g = (l &#x3c;= 0.5) ? l * (s + 1) : l + s - l * s;
						r = l * 2 - g;
						if (a.length &#x3e; 3) {
							a[3] = Number(v[3]);
						}
						a[0] = _hue(h + 1 / 3, r, g);
						a[1] = _hue(h, r, g);
						a[2] = _hue(h - 1 / 3, r, g);
					} else if (v.indexOf(&#x22;=&#x22;) !== -1) { //if relative values are found, just return the raw strings with the relative prefixes
in place.
						return v.match(_relNumExp);
					}
				} else {
					a = v.match(_numExp) || _colorLookup.transparent;
				}
				a[0] = Number(a[0]);
				a[1] = Number(a[1]);
				a[2] = Number(a[2]);
				if (a.length &#x3e; 3) {
					a[3] = Number(a[3]);
				}
			}
			if (toHSL &#x26;&#x26; !wasHSL) {
				r = a[0] / 255;
				g = a[1] / 255;
				b = a[2] / 255;
				max = Math.max(r, g, b);
				min = Math.min(r, g, b);
				l = (max + min) / 2;
				if (max === min) {
					h = s = 0;
				} else {
					d = max - min;
					s = l &#x3e; 0.5 ? d / (2 - max - min) : d / (max + min);
					h = (max === r) ? (g - b) / d + (g &#x3c; b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
					h *= 60;
				}
				a[0] = (h + 0.5) | 0;
				a[1] = (s * 100 + 0.5) | 0;
				a[2] = (l * 100 + 0.5) | 0;
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ColorPropsPlugin.prototype" id="apidoc.module.gsap.ColorPropsPlugin.prototype">module gsap.ColorPropsPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin.prototype._kill" id="apidoc.element.gsap.ColorPropsPlugin.prototype._kill">
        function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_kill
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_kill = function (lookup) {
		var pt = this._firstNumPT,
			prev;
		while (pt) {
			if (pt.p in lookup) {
				if (pt === p._firstNumPT) {
					this._firstNumPT = pt._next;
				}
				if (prev) {
					prev._next = pt._next;
				}
			} else {
				prev = pt;
			}
			pt = pt._next;
		}
		return this._super._kill(lookup);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (!vars &#x26;&#x26; !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i &#x3e; -1) {
				if (tweens[i].<span class="apidocCodeKeywordSpan">_kill</span>(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin.prototype._onInitTween" id="apidoc.element.gsap.ColorPropsPlugin.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween, index) {
				var p, proxy, pt, val;
				this._target = target;
				this._proxy = proxy = ((value.format + &#x22;&#x22;).toUpperCase() === &#x22;NUMBER&#x22;) ? {} : 0;
				for (p in value) {
					if (p !== &#x22;format&#x22;) {
						if (proxy) {
							this._firstNumPT = pt = {_next:this._firstNumPT, t:target, p:p, f:(typeof(target[p]) === &#x22;function&#x22;)};
							proxy[p] = &#x22;rgb(&#x22; + _parseColor(!pt.f ? target[p] : target[ ((p.indexOf(&#x22;set&#x22;) || typeof(target[&#x22;get&#x22; + p.substr(3)]) !== &#x22;
function&#x22;) ? p : &#x22;get&#x22; + p.substr(3)) ]()).join(&#x22;,&#x22;) + &#x22;)&#x22;;
							val = value[p];
							if (typeof(val) === &#x22;function&#x22;) {
								val = val(index, target);
							}
							this._addTween(proxy, p, &#x22;get&#x22;, ((typeof(val) === &#x22;number&#x22;) ? &#x22;rgb(&#x22; + _parseColor(val, false).join(&#x22;,&#x22;) + &#x22;)&#x22; : val), p,
null, null, _colorStringFilter);
						} else {
							this._addTween(target, p, &#x22;get&#x22;, value[p], p, null, null, _colorStringFilter, index);
						}

					}
				}
				return true;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin.prototype.constructor" id="apidoc.element.gsap.ColorPropsPlugin.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ColorPropsPlugin.prototype.setRatio" id="apidoc.element.gsap.ColorPropsPlugin.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.ColorPropsPlugin.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (v) {
				var pt = this._firstNumPT,
					val;
				this._super.setRatio.call(this, v);
				while (pt) {
					val = _parseColor(this._proxy[pt.p], false);
					val = val[0] &#x3c;&#x3c; 16 | val[1] &#x3c;&#x3c; 8 | val[2];
					if (pt.f) {
						this._target[pt.p](val);
					} else {
						this._target[pt.p] = val;
					}
					pt = pt._next;
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.Ease" id="apidoc.module.gsap.Ease">module gsap.Ease</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.Ease.Ease" id="apidoc.element.gsap.Ease.Ease">
        function <span class="apidocSignatureSpan">gsap.</span>Ease
        <span class="apidocSignatureSpan">(func, extraParams, type, power)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Ease = function (func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.Ease.register" id="apidoc.element.gsap.Ease.register">
        function <span class="apidocSignatureSpan">gsap.Ease.</span>register
        <span class="apidocSignatureSpan">(ease, names, types, create)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (ease, names, types, create) {
				var na = names.split(&#x22;,&#x22;),
					i = na.length,
					ta = (types || &#x22;easeIn,easeOut,easeInOut&#x22;).split(&#x22;,&#x22;),
					e, name, j, type;
				while (--i &#x3e; -1) {
					name = na[i];
					e = create ? _class(&#x22;easing.&#x22;+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j &#x3e; -1) {
						type = ta[j];
						_easeMap[name + &#x22;.&#x22; + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.Ease.prototype" id="apidoc.module.gsap.Ease.prototype">module gsap.Ease.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.gsap.Ease.prototype.getRatio" id="apidoc.element.gsap.Ease.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.Ease.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p &#x3c; 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p &#x3c; 0.5) ? r / 2 : 1 - (r / 2);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.EaseLookup" id="apidoc.module.gsap.EaseLookup">module gsap.EaseLookup</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.EaseLookup.find" id="apidoc.element.gsap.EaseLookup.find">
        function <span class="apidocSignatureSpan">gsap.EaseLookup.</span>find
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (s) {
					return Ease.map[s];
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ElasticIn" id="apidoc.module.gsap.ElasticIn">module gsap.ElasticIn</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ElasticIn.ElasticIn" id="apidoc.element.gsap.ElasticIn.ElasticIn">
        function <span class="apidocSignatureSpan">gsap.</span>ElasticIn
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticIn = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ElasticIn.prototype" id="apidoc.module.gsap.ElasticIn.prototype">module gsap.ElasticIn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ElasticIn.prototype.config" id="apidoc.element.gsap.ElasticIn.prototype.config">
        function <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>config
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (amplitude, period) {
				return new C(amplitude, period);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticIn.prototype.constructor" id="apidoc.element.gsap.ElasticIn.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>constructor
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticIn.prototype.getRatio" id="apidoc.element.gsap.ElasticIn.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.ElasticIn.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ElasticInOut" id="apidoc.module.gsap.ElasticInOut">module gsap.ElasticInOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ElasticInOut.ElasticInOut" id="apidoc.element.gsap.ElasticInOut.ElasticInOut">
        function <span class="apidocSignatureSpan">gsap.</span>ElasticInOut
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticInOut = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ElasticInOut.prototype" id="apidoc.module.gsap.ElasticInOut.prototype">module gsap.ElasticInOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ElasticInOut.prototype.config" id="apidoc.element.gsap.ElasticInOut.prototype.config">
        function <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>config
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (amplitude, period) {
				return new C(amplitude, period);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticInOut.prototype.constructor" id="apidoc.element.gsap.ElasticInOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticInOut.prototype.getRatio" id="apidoc.element.gsap.ElasticInOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.ElasticInOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return ((p *= 2) &#x3c; 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math
.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ElasticOut" id="apidoc.module.gsap.ElasticOut">module gsap.ElasticOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ElasticOut.ElasticOut" id="apidoc.element.gsap.ElasticOut.ElasticOut">
        function <span class="apidocSignatureSpan">gsap.</span>ElasticOut
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticOut = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ElasticOut.prototype" id="apidoc.module.gsap.ElasticOut.prototype">module gsap.ElasticOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ElasticOut.prototype.config" id="apidoc.element.gsap.ElasticOut.prototype.config">
        function <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>config
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (amplitude, period) {
				return new C(amplitude, period);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticOut.prototype.constructor" id="apidoc.element.gsap.ElasticOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ElasticOut.prototype.getRatio" id="apidoc.element.gsap.ElasticOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.ElasticOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ExpoIn" id="apidoc.module.gsap.ExpoIn">module gsap.ExpoIn</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ExpoIn.ExpoIn" id="apidoc.element.gsap.ExpoIn.ExpoIn">
        function <span class="apidocSignatureSpan">gsap.</span>ExpoIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ExpoIn.prototype" id="apidoc.module.gsap.ExpoIn.prototype">module gsap.ExpoIn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ExpoIn.prototype.constructor" id="apidoc.element.gsap.ExpoIn.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.ExpoIn.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ExpoIn.prototype.getRatio" id="apidoc.element.gsap.ExpoIn.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.ExpoIn.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ExpoInOut" id="apidoc.module.gsap.ExpoInOut">module gsap.ExpoInOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ExpoInOut.ExpoInOut" id="apidoc.element.gsap.ExpoInOut.ExpoInOut">
        function <span class="apidocSignatureSpan">gsap.</span>ExpoInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ExpoInOut.prototype" id="apidoc.module.gsap.ExpoInOut.prototype">module gsap.ExpoInOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ExpoInOut.prototype.constructor" id="apidoc.element.gsap.ExpoInOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.ExpoInOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ExpoInOut.prototype.getRatio" id="apidoc.element.gsap.ExpoInOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.ExpoInOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return ((p *= 2) &#x3c; 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ExpoOut" id="apidoc.module.gsap.ExpoOut">module gsap.ExpoOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ExpoOut.ExpoOut" id="apidoc.element.gsap.ExpoOut.ExpoOut">
        function <span class="apidocSignatureSpan">gsap.</span>ExpoOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ExpoOut.prototype" id="apidoc.module.gsap.ExpoOut.prototype">module gsap.ExpoOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ExpoOut.prototype.constructor" id="apidoc.element.gsap.ExpoOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.ExpoOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ExpoOut.prototype.getRatio" id="apidoc.element.gsap.ExpoOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.ExpoOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return 1 - Math.pow(2, -10 * p);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.RoughEase" id="apidoc.module.gsap.RoughEase">module gsap.RoughEase</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.RoughEase.RoughEase" id="apidoc.element.gsap.RoughEase.RoughEase">
        function <span class="apidocSignatureSpan">gsap.</span>RoughEase
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RoughEase = function (vars) {
			vars = vars || {};
			var taper = vars.taper || &#x22;none&#x22;,
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === &#x22;number&#x22;) ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i &#x3e; -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === &#x22;none&#x22;) {
					bump = strength;
				} else if (taper === &#x22;out&#x22;) {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === &#x22;in&#x22;) {
					bump = x * x * strength;
				} else if (x &#x3c; 0.5) {  //&#x22;both&#x22; (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//&#x22;both&#x22; (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y &#x3e; 1) {
						y = 1;
					} else if (y &#x3c; 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i &#x3e; -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.RoughEase.prototype" id="apidoc.module.gsap.RoughEase.prototype">module gsap.RoughEase.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.RoughEase.prototype.config" id="apidoc.element.gsap.RoughEase.prototype.config">
        function <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>config
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (vars) {
			return new RoughEase(vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.RoughEase.prototype.constructor" id="apidoc.element.gsap.RoughEase.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>constructor
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (vars) {
			vars = vars || {};
			var taper = vars.taper || &#x22;none&#x22;,
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === &#x22;number&#x22;) ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i &#x3e; -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === &#x22;none&#x22;) {
					bump = strength;
				} else if (taper === &#x22;out&#x22;) {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === &#x22;in&#x22;) {
					bump = x * x * strength;
				} else if (x &#x3c; 0.5) {  //&#x22;both&#x22; (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//&#x22;both&#x22; (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y &#x3e; 1) {
						y = 1;
					} else if (y &#x3c; 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i &#x3e; -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.RoughEase.prototype.getRatio" id="apidoc.element.gsap.RoughEase.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.RoughEase.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
			var pnt = this._prev;
			if (p &#x3e; pnt.t) {
				while (pnt.next &#x26;&#x26; p &#x3e;= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev &#x26;&#x26; p &#x3c;= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SineIn" id="apidoc.module.gsap.SineIn">module gsap.SineIn</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SineIn.SineIn" id="apidoc.element.gsap.SineIn.SineIn">
        function <span class="apidocSignatureSpan">gsap.</span>SineIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SineIn.prototype" id="apidoc.module.gsap.SineIn.prototype">module gsap.SineIn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SineIn.prototype.constructor" id="apidoc.element.gsap.SineIn.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.SineIn.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SineIn.prototype.getRatio" id="apidoc.element.gsap.SineIn.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.SineIn.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SineInOut" id="apidoc.module.gsap.SineInOut">module gsap.SineInOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SineInOut.SineInOut" id="apidoc.element.gsap.SineInOut.SineInOut">
        function <span class="apidocSignatureSpan">gsap.</span>SineInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SineInOut.prototype" id="apidoc.module.gsap.SineInOut.prototype">module gsap.SineInOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SineInOut.prototype.constructor" id="apidoc.element.gsap.SineInOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.SineInOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SineInOut.prototype.getRatio" id="apidoc.element.gsap.SineInOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.SineInOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SineOut" id="apidoc.module.gsap.SineOut">module gsap.SineOut</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SineOut.SineOut" id="apidoc.element.gsap.SineOut.SineOut">
        function <span class="apidocSignatureSpan">gsap.</span>SineOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SineOut.prototype" id="apidoc.module.gsap.SineOut.prototype">module gsap.SineOut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SineOut.prototype.constructor" id="apidoc.element.gsap.SineOut.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.SineOut.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SineOut.prototype.getRatio" id="apidoc.element.gsap.SineOut.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.SineOut.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
				return Math.sin(p * _HALF_PI);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SlowMo" id="apidoc.module.gsap.SlowMo">module gsap.SlowMo</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SlowMo.SlowMo" id="apidoc.element.gsap.SlowMo.SlowMo">
        function <span class="apidocSignatureSpan">gsap.</span>SlowMo
        <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SlowMo = function (linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio &#x3e; 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SlowMo.config" id="apidoc.element.gsap.SlowMo.config">
        function <span class="apidocSignatureSpan">gsap.SlowMo.</span>config
        <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SlowMo.prototype" id="apidoc.module.gsap.SlowMo.prototype">module gsap.SlowMo.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SlowMo.prototype.config" id="apidoc.element.gsap.SlowMo.prototype.config">
        function <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>config
        <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SlowMo.prototype.constructor" id="apidoc.element.gsap.SlowMo.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>constructor
        <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio &#x3e; 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SlowMo.prototype.getRatio" id="apidoc.element.gsap.SlowMo.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.SlowMo.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
			var r = p + (0.5 - p) * this._p;
			if (p &#x3c; this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p &#x3e; this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SteppedEase" id="apidoc.module.gsap.SteppedEase">module gsap.SteppedEase</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SteppedEase.SteppedEase" id="apidoc.element.gsap.SteppedEase.SteppedEase">
        function <span class="apidocSignatureSpan">gsap.</span>SteppedEase
        <span class="apidocSignatureSpan">(steps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SteppedEase = function (steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SteppedEase.config" id="apidoc.element.gsap.SteppedEase.config">
        function <span class="apidocSignatureSpan">gsap.SteppedEase.</span>config
        <span class="apidocSignatureSpan">(steps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (steps) {
			return new SteppedEase(steps);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.SteppedEase.prototype" id="apidoc.module.gsap.SteppedEase.prototype">module gsap.SteppedEase.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.SteppedEase.prototype.config" id="apidoc.element.gsap.SteppedEase.prototype.config">
        function <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>config
        <span class="apidocSignatureSpan">(steps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (steps) {
			return new SteppedEase(steps);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SteppedEase.prototype.constructor" id="apidoc.element.gsap.SteppedEase.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>constructor
        <span class="apidocSignatureSpan">(steps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.SteppedEase.prototype.getRatio" id="apidoc.element.gsap.SteppedEase.prototype.getRatio">
        function <span class="apidocSignatureSpan">gsap.SteppedEase.prototype.</span>getRatio
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRatio = function (p) {
			if (p &#x3c; 0) {
				p = 0;
			} else if (p &#x3e;= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) &#x3e;&#x3e; 0) * this._p1;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.<span class="apidocCodeKeywordSpan">getRatio</span>(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TimelineLite" id="apidoc.module.gsap.TimelineLite">module gsap.TimelineLite</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.TimelineLite" id="apidoc.element.gsap.TimelineLite.TimelineLite">
        function <span class="apidocSignatureSpan">gsap.</span>TimelineLite
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimelineLite = function (vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.exportRoot" id="apidoc.element.gsap.TimelineLite.exportRoot">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.</span>exportRoot
        <span class="apidocSignatureSpan">(vars, ignoreDelayedCalls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportRoot = function (vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite &#x26;&#x26; tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (time &#x3e; totalDuration &#x26;&#x26; !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale
);
					if (!tl._dirty) { //for performance improvement. If the parent&#x27;s cache is already dirty, it already took care of marking
 the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will
 also ensure that they&#x27;re lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite
.<span class="apidocCodeKeywordSpan">exportRoot</span>() is performed when there&#x27;s a paused tween on the root, the export will
 not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed
. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TimelineLite._internals" id="apidoc.module.gsap.TimelineLite._internals">module gsap.TimelineLite._internals</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TimelineLite._internals.pauseCallback" id="apidoc.element.gsap.TimelineLite._internals.pauseCallback">
        function <span class="apidocSignatureSpan">gsap.TimelineLite._internals.</span>pauseCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseCallback = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TimelineLite.prototype" id="apidoc.module.gsap.TimelineLite.prototype">module gsap.TimelineLite.prototype</a></h1>
















    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype._contains" id="apidoc.element.gsap.TimelineLite.prototype._contains">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_contains
        <span class="apidocSignatureSpan">(tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_contains = function (tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline
 completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i &#x3e; -1) {
				if (tweens[i].timeline === this || (nested &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">_contains</span>(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype._enabled" id="apidoc.element.gsap.TimelineLite.prototype._enabled">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_enabled
        <span class="apidocSignatureSpan">(enabled, ignoreTimeline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_enabled = function (enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() &#x3e; value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the
 current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let
it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue
 that it should jump to its end state, that&#x27;s not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime &#x26;&#x26; tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl.<span class="apidocCodeKeywordSpan">_enabled</span>(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype._hasPausedChild" id="apidoc.element.gsap.TimelineLite.prototype._hasPausedChild">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_hasPausedChild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_hasPausedChild = function () {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) &#x26;&#x26; tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce, pauseTween, curTime;
			if (time &#x3e;= totalDur - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts
.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this.<span class="apidocCodeKeywordSpan">_hasPausedChild</span>()) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
					if (this._duration === 0) if ((time &#x3c;= 0 &#x26;&#x26; time &#x3e;= -0.0000001) || this._rawPrevTime &#x3c; 0 || this._rawPrevTime
 === _tinyNum) if (this._rawPrevTime !== time &#x26;&#x26; this._first) {
						internalForce = true;
						if (this._rawPrevTime &#x3e; _tinyNum) {
							callback = &#x22;onReverseComplete&#x22;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype._kill" id="apidoc.element.gsap.TimelineLite.prototype._kill">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_kill
        <span class="apidocSignatureSpan">(vars, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_kill = function (vars, target) {
			if (!vars &#x26;&#x26; !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i &#x3e; -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (!vars &#x26;&#x26; !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i &#x3e; -1) {
				if (tweens[i].<span class="apidocCodeKeywordSpan">_kill</span>(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype._parseTimeOrLabel" id="apidoc.element.gsap.TimelineLite.prototype._parseTimeOrLabel">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_parseTimeOrLabel
        <span class="apidocSignatureSpan">(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we&#x27;re about to add a tween/timeline (or an array of them) that&#x27;s already a child of this timeline, we should remove it first
 so that it doesn&#x27;t contaminate the duration().
			if (ignore instanceof Animation &#x26;&#x26; ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore &#x26;&#x26; ((ignore instanceof Array) || (ignore.push &#x26;&#x26; _isArray(ignore)))) {
				i = ignore.length;
				while (--i &#x3e; -1) {
					if (ignore[i] instanceof Animation &#x26;&#x26; ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === &#x22;string&#x22;) {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent &#x26;&#x26; typeof(timeOrLabel) === &#x22;number&#x22; &#x26;&#x26; this._labels[offsetOrLabel
] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === &#x22;string&#x22; &#x26;&#x26; (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number
 like &#x22;1&#x22;, check to see if there&#x27;s a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf(&#x22;=&#x22;);
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + &#x22;1&#x22;, 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i &#x3e; 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this.<span class="apidocCodeKeywordSpan">_parseTimeOrLabel</span>(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time &#x26;&#x26; !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype._remove" id="apidoc.element.gsap.TimelineLite.prototype._remove">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>_remove
        <span class="apidocSignatureSpan">(tween, skipDisable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_remove = function (tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time &#x3e; this.duration()) {
				this._time = this._duration;
				this._totalTime = this._totalDuration;
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root.<span class="apidocCodeKeywordSpan">_remove</span>(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite &#x26;&#x26; tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.add" id="apidoc.element.gsap.TimelineLite.prototype.add">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>add
        <span class="apidocSignatureSpan">(value, position, align, stagger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== &#x22;number&#x22;) {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value &#x26;&#x26; value.push &#x26;&#x26; _isArray(value))) {
					align = align || &#x22;normal&#x22;;
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i &#x3c; l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== &#x22;string&#x22; &#x26;&#x26; typeof(child) !== &#x22;function&#x22;) {
							if (align === &#x22;sequence&#x22;) {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === &#x22;start&#x22;) {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === &#x22;string&#x22;) {
					return this.addLabel(value, position);
				} else if (typeof(value) === &#x22;function&#x22;) {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw(&#x22;Cannot add &#x22; + value + &#x22; into the timeline; it is not a tween, timeline, function, or string.&#x22;);
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again
 so that it renders properly. We should also align the playhead with the parent timeline&#x27;s when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration &#x3c; this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() &#x3e; value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current
 rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish
, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that
 it should jump to its end state, that&#x27;s not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime &#x26;&#x26; tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.<span class="apidocCodeKeywordSpan">add</span>(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.addLabel" id="apidoc.element.gsap.TimelineLite.prototype.addLabel">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>addLabel
        <span class="apidocSignatureSpan">(label, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addLabel = function (label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === &#x22;string&#x22;) {
					return this.<span class="apidocCodeKeywordSpan">addLabel</span>(value, position);
				} else if (typeof(value) === &#x22;function&#x22;) {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw(&#x22;Cannot add &#x22; + value + &#x22; into the timeline; it is not a tween, timeline, function, or string.&#x22;);
				}
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.addPause" id="apidoc.element.gsap.TimelineLite.prototype.addPause">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>addPause
        <span class="apidocSignatureSpan">(position, callback, params, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPause = function (position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = &#x22;isPause&#x22;;
			this._hasPause = true;
			return this.add(t, position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end
 values should be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive
 time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime &#x3c; 0 || (time &#x3c;= 0 &#x26;&#x26; time &#x3e;= -0.0000001) || (prevRawPrevTime === _tinyNum &#x26
;&#x26; this.data !== &#x22;isPause&#x22;)) if (prevRawPrevTime !== time) { //note: when this.data is &#x22;isPause&#x22;, it&#x27
;s a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words
, tl.<span class="apidocCodeKeywordSpan">addPause</span>(1).play(1) shouldn&#x27;t pause.
						force = true;
						if (prevRawPrevTime &#x3e; _tinyNum) {
							callback = &#x22;onReverseComplete&#x22;;
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead
 arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the
 playhead moves again (next time), it&#x27;ll trigger the callback. If events are NOT suppressed, obviously the callback would be
 triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both
. Imagine doing a timeline.seek(0) and there&#x27;s a callback that sits at 0. Since events are suppressed on that seek() by default
, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively
 expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable
 which would increase memory usage. This technique is less readable, but more efficient.
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.append" id="apidoc.element.gsap.TimelineLite.prototype.append">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>append
        <span class="apidocSignatureSpan">(value, offsetOrLabel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.appendMultiple" id="apidoc.element.gsap.TimelineLite.prototype.appendMultiple">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>appendMultiple
        <span class="apidocSignatureSpan">(tweens, offsetOrLabel, align, stagger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.call" id="apidoc.element.gsap.TimelineLite.prototype.call">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>call
        <span class="apidocSignatureSpan">(callback, params, scope, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">call = function (callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	&#x22;use strict&#x22;;

	_gsScope._gsDefine(&#x22;TimelineLite&#x22;, [&#x22;core.Animation&#x22;,&#x22;core.SimpleTimeline&#x22;,&#x22;TweenLite&#x22;],
function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.<span class="apidocCodeKeywordSpan">call</span>(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.clear" id="apidoc.element.gsap.TimelineLite.prototype.clear">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>clear
        <span class="apidocSignatureSpan">(labels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i &#x3e; -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.constructor" id="apidoc.element.gsap.TimelineLite.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>constructor
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.duration" id="apidoc.element.gsap.TimelineLite.prototype.duration">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>duration
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 &#x26;&#x26; value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					throw(&#x22;Cannot add &#x22; + value + &#x22; into the timeline; it is not a tween, timeline, function, or string.&#x22;);
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again
 so that it renders properly. We should also align the playhead with the parent timeline&#x27;s when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration &#x3c; this.<span class="apidocCodeKeywordSpan
">duration</span>()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() &#x3e; value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the
 current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let
it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue
 that it should jump to its end state, that&#x27;s not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime &#x26;&#x26; tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.from" id="apidoc.element.gsap.TimelineLite.prototype.from">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>from
        <span class="apidocSignatureSpan">(target, duration, vars, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).<span class="apidocCodeKeywordSpan">from</span>(
target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.fromTo" id="apidoc.element.gsap.TimelineLite.prototype.fromTo">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>fromTo
        <span class="apidocSignatureSpan">(target, duration, fromVars, toVars, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromTo = function (target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.<span class="apidocCodeKeywordSpan">fromTo</span>(target, duration, fromVars, toVars), position
) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope,
smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === &#x22;string&#x22;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.getChildren" id="apidoc.element.gsap.TimelineLite.prototype.getChildren">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>getChildren
        <span class="apidocSignatureSpan">(nested, tweens, timelines, ignoreBeforeTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime &#x3c; ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.<span class="apidocCodeKeywordSpan">getChildren</span>(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.getLabelTime" id="apidoc.element.gsap.TimelineLite.prototype.getLabelTime">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>getLabelTime
        <span class="apidocSignatureSpan">(label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLabelTime = function (label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.getTweensOf" id="apidoc.element.gsap.TimelineLite.prototype.getTweensOf">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>getTweensOf
        <span class="apidocSignatureSpan">(target, nested)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTweensOf = function (target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline
 completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i &#x3e; -1) {
				if (tweens[i].timeline === this || (nested &#x26;&#x26; this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline
 completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.<span class="apidocCodeKeywordSpan">getTweensOf</span>(target);
			i = tweens.length;
			while (--i &#x3e; -1) {
				if (tweens[i].timeline === this || (nested &#x26;&#x26; this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.gotoAndPlay" id="apidoc.element.gsap.TimelineLite.prototype.gotoAndPlay">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>gotoAndPlay
        <span class="apidocSignatureSpan">(position, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gotoAndPlay = function (position, suppressEvents) {
			return this.play(position, suppressEvents);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.gotoAndStop" id="apidoc.element.gsap.TimelineLite.prototype.gotoAndStop">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>gotoAndStop
        <span class="apidocSignatureSpan">(position, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gotoAndStop = function (position, suppressEvents) {
			return this.pause(position, suppressEvents);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.insert" id="apidoc.element.gsap.TimelineLite.prototype.insert">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>insert
        <span class="apidocSignatureSpan">(value, position, align, stagger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.insertMultiple" id="apidoc.element.gsap.TimelineLite.prototype.insertMultiple">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>insertMultiple
        <span class="apidocSignatureSpan">(value, position, align, stagger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertMultiple = function (value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.invalidate" id="apidoc.element.gsap.TimelineLite.prototype.invalidate">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>invalidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidate = function () {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.<span class="apidocCodeKeywordSpan">invalidate</span>();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.paused" id="apidoc.element.gsap.TimelineLite.prototype.paused">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>paused
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">paused = function (value) {
			if (!value) { //if there&#x27;s a pause directly at the spot from where we&#x27;re unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time &#x26;&#x26; tween.data === &#x22;isPause&#x22;) {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine
whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won&#x27;t fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === &#x22;number&#x22;) ? position : this._parseTimeOrLabel(position), (suppressEvents
 !== false));
		};

		p.stop = function() {
			return this.<span class="apidocCodeKeywordSpan">paused</span>(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.rawTime" id="apidoc.element.gsap.TimelineLite.prototype.rawTime">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>rawTime
        <span class="apidocSignatureSpan">(wrapRepeats)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rawTime = function (wrapRepeats) {
			return (wrapRepeats &#x26;&#x26; (this._paused || (this._repeat &#x26;&#x26; this.time() &#x3e; 0 &#x26;&#x26; this.totalProgress() &#x3c; 1))) ? this._totalTime % (
this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) *
this._timeScale;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again
 so that it renders properly. We should also align the playhead with the parent timeline&#x27;s when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration &#x3c; this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.<span class="apidocCodeKeywordSpan">rawTime</span>() &#x3e; value._startTime); //if the tween is placed
on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because
sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to
its end state. While technically one could argue that it should jump to its end state, that&#x27;s not what users intuitively expect
.
				while (tl._timeline) {
					if (beforeRawTime &#x26;&#x26; tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.recent" id="apidoc.element.gsap.TimelineLite.prototype.recent">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>recent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recent = function () {
			return this._recent;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.remove" id="apidoc.element.gsap.TimelineLite.prototype.remove">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>remove
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it&#x27;s removed
, default it to the root timeline so that if it gets played again, it doesn&#x27;t jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration
() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || (value &#x26;&#x26; value.push &#x26;&#x26; _isArray(value))) {
				var i = value.length;
				while (--i &#x3e; -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === &#x22;string&#x22;) {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it&#x27
;s removed, default it to the root timeline so that if it gets played again, it doesn&#x27;t jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration
() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || (value &#x26;&#x26; value.push &#x26;&#x26; _isArray(value))) {
				var i = value.length;
				while (--i &#x3e; -1) {
					this.<span class="apidocCodeKeywordSpan">remove</span>(value[i]);
				}
				return this;
			} else if (typeof(value) === &#x22;string&#x22;) {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.removeLabel" id="apidoc.element.gsap.TimelineLite.prototype.removeLabel">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>removeLabel
        <span class="apidocSignatureSpan">(label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeLabel = function (label) {
			delete this._labels[label];
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			} else if (value instanceof Array || (value &#x26;&#x26; value.push &#x26;&#x26; _isArray(value))) {
				var i = value.length;
				while (--i &#x3e; -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === &#x22;string&#x22;) {
				return this.<span class="apidocCodeKeywordSpan">removeLabel</span>(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.render" id="apidoc.element.gsap.TimelineLite.prototype.render">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>render
        <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce, pauseTween, curTime;
			if (time &#x3e;= totalDur - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
					if (this._duration === 0) if ((time &#x3c;= 0 &#x26;&#x26; time &#x3e;= -0.0000001) || this._rawPrevTime &#x3c; 0 || this._rawPrevTime === _tinyNum)
if (this._rawPrevTime !== time &#x26;&#x26; this._first) {
						internalForce = true;
						if (this._rawPrevTime &#x3e; _tinyNum) {
							callback = &#x22;onReverseComplete&#x22;;
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the
playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed
 so that when the playhead moves again (next time), it&#x27;ll trigger the callback. If events are NOT suppressed, obviously the callback
 would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot
, not both. Imagine doing a timeline.seek(0) and there&#x27;s a callback that sits at 0. Since events are suppressed on that seek() by
 default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people
 intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property
/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being
 fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating
 point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0
.7.

			} else if (time &#x3c; 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 &#x26;&#x26; this._rawPrevTime !== _tinyNum &#x26;&#x26; (this._rawPrevTime &#x3e; 0 || (time &#x3c; 0 &#x26;&#x26; this
._rawPrevTime &#x3e;= 0)))) {
					callback = &#x22;onReverseComplete&#x22;;
					isComplete = this._reversed;
				}
				if (time &#x3c; 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren &#x26;&#x26; this._reversed) { //ensures proper GC if a timeline is resumed after it&#x27;s finished
 reversing.
						internalForce = isComplete = true;
						callback = &#x22;onReverseComplete&#x22;;
					} else if (this._rawPrevTime &#x3e;= 0 &#x26;&#x26; this._first) { //when going back beyond the start, force a render so that zero-duration
 tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline&#x27;s playhead lands exactly
 at this timeline&#x27;s startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state
.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the
 playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed
 so that when the playhead moves again (next time), it&#x27;ll trigger the callback. If events are NOT suppressed, obviously the callbac ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (curTime !== this._time || (this._paused &#x26;&#x26; !prevPaused)) { //in case a tween pauses or seeks the timeline when
 rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime &#x3c;= curTime &#x26;&#x26; !tween._paused &#x26;&#x26; !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.<span class="apidocCodeKeywordSpan">render</span>((time - tween._startTime) * tween._timeScale, suppressEvents, force
);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale
), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.seek" id="apidoc.element.gsap.TimelineLite.prototype.seek">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>seek
        <span class="apidocSignatureSpan">(position, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seek = function (position, suppressEvents) {
			return this.totalTime((typeof(position) === &#x22;number&#x22;) ? position : this._parseTimeOrLabel(position), (suppressEvents !== false
));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (this._duration === 0) if ((time &#x3c;= 0 &#x26;&#x26; time &#x3e;= -0.0000001) || this._rawPrevTime &#x3c; 0 || this._rawPrevTime
 === _tinyNum) if (this._rawPrevTime !== time &#x26;&#x26; this._first) {
						internalForce = true;
						if (this._rawPrevTime &#x3e; _tinyNum) {
							callback = &#x22;onReverseComplete&#x22;;
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the
playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed
 so that when the playhead moves again (next time), it&#x27;ll trigger the callback. If events are NOT suppressed, obviously the
 callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this
 exact spot, not both. Imagine doing a timeline.<span class="apidocCodeKeywordSpan">seek</span>(0) and there&#x27;s a callback that
 sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position
, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number
 to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less
 readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being
 fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating
 point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0
.7.

			} else if (time &#x3c; 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 &#x26;&#x26; this._rawPrevTime !== _tinyNum &#x26;&#x26; (this._rawPrevTime &#x3e
; 0 || (time &#x3c; 0 &#x26;&#x26; this._rawPrevTime &#x3e;= 0)))) {
					callback = &#x22;onReverseComplete&#x22;;
					isComplete = this._reversed;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.set" id="apidoc.element.gsap.TimelineLite.prototype.set">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>set
        <span class="apidocSignatureSpan">(target, vars, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time &#x26;&#x26; !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.<span class="apidocCodeKeywordSpan">set</span
>(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.shiftChildren" id="apidoc.element.gsap.TimelineLite.prototype.shiftChildren">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>shiftChildren
        <span class="apidocSignatureSpan">(amount, adjustLabels, ignoreBeforeTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime &#x3e;= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] &#x3e;= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
							prevStart = tween._startTime;
						}
						if (tween._startTime &#x3c; 0 &#x26;&#x26; !tween._paused) { //children aren&#x27;t allowed to have negative startTimes unless
 smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.<span class="apidocCodeKeywordSpan">shiftChildren</span>(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end &#x3e; max) {
							max = end;
						}
						tween = prev;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.staggerFrom" id="apidoc.element.gsap.TimelineLite.prototype.staggerFrom">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>staggerFrom
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.staggerFromTo" id="apidoc.element.gsap.TimelineLite.prototype.staggerFromTo">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>staggerFromTo
        <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.staggerTo" id="apidoc.element.gsap.TimelineLite.prototype.staggerTo">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>staggerTo
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope,
smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === &#x22;string&#x22;) {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger &#x3c; 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i &#x3c; targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.<span class="apidocCodeKeywordSpan">staggerTo</span>(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams
, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope
) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.stop" id="apidoc.element.gsap.TimelineLite.prototype.stop">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function () {
			return this.paused(true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.to" id="apidoc.element.gsap.TimelineLite.prototype.to">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>to
        <span class="apidocSignatureSpan">(target, duration, vars, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to = function (target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.<span class="apidocCodeKeywordSpan">to</span>(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.totalDuration" id="apidoc.element.gsap.TimelineLite.prototype.totalDuration">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>totalDuration
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween&#x27;s cache is clean before analyzing it.
						}
						if (tween._startTime &#x3e; prevStart &#x26;&#x26; this._sortChildren &#x26;&#x26; !tween._paused) { //in case one of the tweens shifted out of order
, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime &#x3c; 0 &#x26;&#x26; !tween._paused) { //children aren&#x27;t allowed to have negative startTimes unless smoothChildTiming
 is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end &#x3e; max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (value &#x26;&#x26; this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					for (i = 0; i &#x3c; l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== &#x22;string&#x22; &#x26;&#x26; typeof(child) !== &#x22;function&#x22;) {
							if (align === &#x22;sequence&#x22;) {
								curTime = child._startTime + (child.<span class="apidocCodeKeywordSpan">totalDuration</span>() / child._timeScale);
							} else if (align === &#x22;start&#x22;) {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.totalTime" id="apidoc.element.gsap.TimelineLite.prototype.totalTime">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>totalTime
        <span class="apidocSignatureSpan">(time, suppressEvents, uncapped)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">totalTime = function (time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again
 so that it renders properly. We should also align the playhead with the parent timeline&#x27;s when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration &#x3c; this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() &#x3e; value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the
 current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let
it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue
 that it should jump to its end state, that&#x27;s not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime &#x26;&#x26; tl._timeline.smoothChildTiming) {
						tl.<span class="apidocCodeKeywordSpan">totalTime</span>(tl._totalTime, true); //moves the timeline (shifts its startTime)
if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineLite.prototype.usesFrames" id="apidoc.element.gsap.TimelineLite.prototype.usesFrames">
        function <span class="apidocSignatureSpan">gsap.TimelineLite.prototype.</span>usesFrames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">usesFrames = function () {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TimelineMax" id="apidoc.module.gsap.TimelineMax">module gsap.TimelineMax</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.TimelineMax" id="apidoc.element.gsap.TimelineMax.TimelineMax">
        function <span class="apidocSignatureSpan">gsap.</span>TimelineMax
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimelineMax = function (vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TimelineMax.prototype" id="apidoc.module.gsap.TimelineMax.prototype">module gsap.TimelineMax.prototype</a></h1>














    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.addCallback" id="apidoc.element.gsap.TimelineMax.prototype.addCallback">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>addCallback
        <span class="apidocSignatureSpan">(callback, position, params, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addCallback = function (callback, position, params, scope) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.constructor" id="apidoc.element.gsap.TimelineMax.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>constructor
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.currentLabel" id="apidoc.element.gsap.TimelineMax.prototype.currentLabel">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>currentLabel
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentLabel = function (value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.getActive" id="apidoc.element.gsap.TimelineMax.prototype.getActive">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getActive
        <span class="apidocSignatureSpan">(nested, tweens, timelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getActive = function (nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
				all = this.getChildren(nested, tweens, timelines),
				cnt = 0,
				l = all.length,
				i, tween;
			for (i = 0; i &#x3c; l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.getLabelAfter" id="apidoc.element.gsap.TimelineMax.prototype.getLabelAfter">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getLabelAfter
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLabelAfter = function (time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i &#x3c; l; i++) {
				if (labels[i].time &#x3e; time) {
					return labels[i].name;
				}
			}
			return null;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.getLabelBefore" id="apidoc.element.gsap.TimelineMax.prototype.getLabelBefore">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getLabelBefore
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLabelBefore = function (time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i &#x3e; -1) {
				if (labels[i].time &#x3c; time) {
					return labels[i].name;
				}
			}
			return null;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.getLabelsArray" id="apidoc.element.gsap.TimelineMax.prototype.getLabelsArray">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>getLabelsArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLabelsArray = function () {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.invalidate" id="apidoc.element.gsap.TimelineMax.prototype.invalidate">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>invalidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidate = function () {
			this._locked = false; //unlock and set cycle in case invalidate() is called from inside an onRepeat
			return TimelineLite.prototype.invalidate.call(this);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.<span class="apidocCodeKeywordSpan">invalidate</span>();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.progress" id="apidoc.element.gsap.TimelineMax.prototype.progress">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>progress
        <span class="apidocSignatureSpan">(value, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress = function (value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo &#x26;&#x26; (this._cycle &#x26;
1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.removeCallback" id="apidoc.element.gsap.TimelineMax.prototype.removeCallback">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>removeCallback
        <span class="apidocSignatureSpan">(callback, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeCallback = function (callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i &#x3e; -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.removePause" id="apidoc.element.gsap.TimelineMax.prototype.removePause">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>removePause
        <span class="apidocSignatureSpan">(position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePause = function (position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.render" id="apidoc.element.gsap.TimelineMax.prototype.render">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>render
        <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused,
				prevCycle = this._cycle,
				tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
			if (time &#x3e;= totalDur - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
					if (this._duration === 0) if ((time &#x3c;= 0 &#x26;&#x26; time &#x3e;= -0.0000001) || prevRawPrevTime &#x3c; 0 || prevRawPrevTime === _tinyNum) if (
prevRawPrevTime !== time &#x26;&#x26; this._first) {
						internalForce = true;
						if (prevRawPrevTime &#x3e; _tinyNum) {
							callback = &#x22;onReverseComplete&#x22;;
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the
playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed
 so that when the playhead moves again (next time), it&#x27;ll trigger the callback. If events are NOT suppressed, obviously the callback
 would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot
, not both. Imagine doing a timeline.seek(0) and there&#x27;s a callback that sits at 0. Since events are suppressed on that seek() by
 default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people
 intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property
/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo &#x26;&#x26; (this._cycle &#x26; 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being
 fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating
 point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0
.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which
 case adding 0.00000001, for example, causes it to act like nothing was added.
				}
				
			} else if (time &#x3c; 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 &#x26;&#x26; prevRawPrevTime !== _tinyNum &#x26;&#x26; (prevRawPrevTime &#x3e; 0 || (time &#x3c; 0 &#x26;&#x26; prevRawPrevTime &#x3e;=
0)) &#x26;&#x26; !this._locked)) { //edge case for checking time &#x3c; 0 &#x26;&#x26; prevRawPrevTime &#x3e;= 0: a zero-duration fromTo() tween inside a zero
-duration timeline (yeah, very rare)
					callback = &#x22;onReverseComplete&#x22;;
					isComplete = this._reversed;
				}
				if (time &#x3c; 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren &#x26;&#x26; this._reversed) {
						internalForce = isComplete = true;
						callback = &#x22;onReverseComplete&#x22;;
					} else if (prevRawPrevTime &#x3e;= 0 &#x26;&#x26; this._first) { //when going back beyond the start, force a render so that zero-duration
tweens that sit at the very beginning render their start values properly. Otherwise, if the parent tim ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (curTime !== this._time || (this._paused &#x26;&#x26; !prevPaused)) { //in case a tween pauses or seeks the timeline when
 rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime &#x3c;= curTime &#x26;&#x26; !tween._paused &#x26;&#x26; !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.<span class="apidocCodeKeywordSpan">render</span>((time - tween._startTime) * tween._timeScale, suppressEvents, force
);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale
), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.repeat" id="apidoc.element.gsap.TimelineMax.prototype.repeat">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>repeat
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.repeatDelay" id="apidoc.element.gsap.TimelineMax.prototype.repeatDelay">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>repeatDelay
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.time" id="apidoc.element.gsap.TimelineMax.prototype.time">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>time
        <span class="apidocSignatureSpan">(value, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value &#x3e; this._duration) {
				value = this._duration;
			}
			if (this._yoyo &#x26;&#x26; (this._cycle &#x26; 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function(wrapRepeats) {
			return (wrapRepeats &#x26;&#x26; (this._paused || (this._repeat &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">time</span
>() &#x3e; 0 &#x26;&#x26; this.totalProgress() &#x3c; 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused
 ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.totalDuration" id="apidoc.element.gsap.TimelineMax.prototype.totalDuration">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>totalDuration
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this
._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1 || !value) ? this : this.timeScale( this.totalDuration() / value );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					for (i = 0; i &#x3c; l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== &#x22;string&#x22; &#x26;&#x26; typeof(child) !== &#x22;function&#x22;) {
							if (align === &#x22;sequence&#x22;) {
								curTime = child._startTime + (child.<span class="apidocCodeKeywordSpan">totalDuration</span>() / child._timeScale);
							} else if (align === &#x22;start&#x22;) {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.totalProgress" id="apidoc.element.gsap.TimelineMax.prototype.totalProgress">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>totalProgress
        <span class="apidocSignatureSpan">(value, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">totalProgress = function (value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents
);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function(wrapRepeats) {
			return (wrapRepeats &#x26;&#x26; (this._paused || (this._repeat &#x26;&#x26; this.time() &#x3e; 0 &#x26;&#x26; this.<span class
="apidocCodeKeywordSpan">totalProgress</span>() &#x3c; 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused
 ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.tweenFromTo" id="apidoc.element.gsap.TimelineMax.prototype.tweenFromTo">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>tweenFromTo
        <span class="apidocSignatureSpan">(fromPosition, toPosition, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tweenFromTo = function (fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], callbackScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.tweenTo" id="apidoc.element.gsap.TimelineMax.prototype.tweenTo">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>tweenTo
        <span class="apidocSignatureSpan">(position, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tweenTo = function (position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false},
				Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite,
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new Engine(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() &#x26;&#x26; duration === t.duration()) { //don&#x27;t make the duration zero - if it&#x27;s supposed to be
zero, don&#x27;t worry because it&#x27;s already initting the tween and will complete immediately, effectively making the duration zero anyway
. If we make duration zero, the tween won&#x27;t run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale );
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don&#x27;t want to overwrite it.
					vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []); //don&#x27;t use t._callback(&#x22;onStart
&#x22;) or it&#x27;ll point to the copy.onStart and we&#x27;ll get a recursion error.
				}
			};
			return t;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TimelineMax.prototype.yoyo" id="apidoc.element.gsap.TimelineMax.prototype.yoyo">
        function <span class="apidocSignatureSpan">gsap.TimelineMax.prototype.</span>yoyo
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite" id="apidoc.module.gsap.TweenLite">module gsap.TweenLite</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite.TweenLite" id="apidoc.element.gsap.TweenLite.TweenLite">
        function <span class="apidocSignatureSpan">gsap.</span>TweenLite
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenLite = function (target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)

				if (target == null) {
					throw &#x22;Cannot tween a null target.&#x22;;
				}

				this.target = target = (typeof(target) !== &#x22;string&#x22;) ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length &#x26;&#x26; target !== window &#x26;&#x26; target[0] &#x26;&#x26; (target[0] === window || (target[0].nodeType
 &#x26;&#x26; target[0].style &#x26;&#x26; !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === &#x22;number
&#x22;) ? overwrite &#x3e;&#x3e; 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push &#x26;&#x26; _isArray(target))) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
					this._targets = targets = _slice(target);  //don&#x27;t use Array.prototype.slice.call(target, 0) because that doesn&#x27;t work in IE8
 with a NodeList that&#x27;s returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i &#x3c; targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === &#x22;string&#x22;) {
							targ = targets[i--] = TweenLite.selector(targ); //in case it&#x27;s an array of strings
							if (typeof(targ) === &#x22;string&#x22;) {
								targets.splice(i+1, 1); //to avoid an endless loop (can&#x27;t imagine why the selector would return a string, but just in case
)
							}
							continue;
						} else if (targ.length &#x26;&#x26; targ !== window &#x26;&#x26; targ[0] &#x26;&#x26; (targ[0] === window || (targ[0].nodeType &#x26;&#x26; targ[0].style &#x26;&#x26; !targ
.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level
 and pull things out if necessary. Also note that &#x3c;select&#x3e; elements pass all the criteria regarding length and the first child having
 style, so we must also check to ensure the target isn&#x27;t an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length &#x3e; 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length &#x3e; 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 &#x26;&#x26; this._delay === 0 &#x26;&#x26; this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() &#x22;force&#x22; parameter to true because we want to allow
 lazying by default (using the &#x22;force&#x22; parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._onPluginEvent" id="apidoc.element.gsap.TweenLite._onPluginEvent">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>_onPluginEvent
        <span class="apidocSignatureSpan">(type, tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onPluginEvent = function (type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === &#x22;_onInitAllProps&#x22;) {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin
 applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 &#x26;&#x26; pt2.pr &#x3e; pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === &#x22;function&#x22;) if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
			}

			if (initPlugins) {
				TweenLite.<span class="apidocCodeKeywordSpan">_onPluginEvent</span>(&#x22;_onInitAllProps&#x22;, this); //reorders the array
 in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== &#x22;function&#x22;) { //if all tweening properties have been overwritten
, kill the tween. If the target is a function, it&#x27;s probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.defaultStringFilter" id="apidoc.element.gsap.TweenLite.defaultStringFilter">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>defaultStringFilter
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultStringFilter = function (a) {
			var combined = a[0] + a[1],
				toHSL;
			if (_colorExp.test(combined)) {
				toHSL = (combined.indexOf(&#x22;hsl(&#x22;) !== -1 || combined.indexOf(&#x22;hsla(&#x22;) !== -1);
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.delayedCall" id="apidoc.element.gsap.TweenLite.delayedCall">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>delayedCall
        <span class="apidocSignatureSpan">(delay, callback, params, scope, useFrames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayedCall = function (delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete
:callback, onReverseCompleteParams:params, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope
) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.<span class="apidocCodeKeywordSpan">delayedCall</span>(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time &#x26;&#x26; !this._paused);
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.from" id="apidoc.element.gsap.TweenLite.from">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>from
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).<span class="apidocCodeKeywordSpan">from</span>(
target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.fromTo" id="apidoc.element.gsap.TweenLite.fromTo">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>fromTo
        <span class="apidocSignatureSpan">(target, duration, fromVars, toVars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromTo = function (target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.<span class="apidocCodeKeywordSpan">fromTo</span>(target, duration, fromVars, toVars), position
) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope,
smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === &#x22;string&#x22;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.getTweensOf" id="apidoc.element.gsap.TweenLite.getTweensOf">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>getTweensOf
        <span class="apidocSignatureSpan">(target, onlyActive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTweensOf = function (target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== &#x22;string&#x22;) ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
				i = target.length;
				a = [];
				while (--i &#x3e; -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i &#x3e; -1) {
					t = a[i];
					j = i;
					while (--j &#x3e; -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i &#x3e; -1) {
					if (a[i]._gc || (onlyActive &#x26;&#x26; !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline
 completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.<span class="apidocCodeKeywordSpan">getTweensOf</span>(target);
			i = tweens.length;
			while (--i &#x3e; -1) {
				if (tweens[i].timeline === this || (nested &#x26;&#x26; this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.killDelayedCallsTo" id="apidoc.element.gsap.TweenLite.killDelayedCallsTo">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>killDelayedCallsTo
        <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killDelayedCallsTo = function (target, onlyActive, vars) {
			if (typeof(onlyActive) === &#x22;object&#x22;) {
				vars = onlyActive; //for backwards compatibility (before &#x22;onlyActive&#x22; parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i &#x3e; -1) {
				a[i]._kill(vars, target);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.killTweensOf" id="apidoc.element.gsap.TweenLite.killTweensOf">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>killTweensOf
        <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killTweensOf = function (target, onlyActive, vars) {
			if (typeof(onlyActive) === &#x22;object&#x22;) {
				vars = onlyActive; //for backwards compatibility (before &#x22;onlyActive&#x22; parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i &#x3e; -1) {
				a[i]._kill(vars, target);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.lagSmoothing" id="apidoc.element.gsap.TweenLite.lagSmoothing">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>lagSmoothing
        <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lagSmoothing = function (threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		TweenLite.version = &#x22;1.19.1&#x22;;
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = &#x22;auto&#x22;;
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.<span class="apidocCodeKeywordSpan">lagSmoothing</span>(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.render" id="apidoc.element.gsap.TweenLite.render">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>render
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function () {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine
 refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame &#x3e;= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i &#x3e; -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they&#x27;re all paused, make the _timer sleep to reduce load on the
CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep &#x26;&#x26; !_rootFramesTimeline._first &#x26;&#x26; _ticker._listeners.tick.length === 1) {
						while (p &#x26;&#x26; p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (curTime !== this._time || (this._paused &#x26;&#x26; !prevPaused)) { //in case a tween pauses or seeks the timeline when
 rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime &#x3c;= curTime &#x26;&#x26; !tween._paused &#x26;&#x26; !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.<span class="apidocCodeKeywordSpan">render</span>((time - tween._startTime) * tween._timeScale, suppressEvents, force
);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale
), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.selector" id="apidoc.element.gsap.TweenLite.selector">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>selector
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selector = function (e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(_doc) === &#x22;undefined&#x22;) ? e : (_doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById((e.charAt
(0) === &#x22;#&#x22;) ? e.substr(1) : e));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope,
smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === &#x22;string&#x22;) {
				targets = TweenLite.<span class="apidocCodeKeywordSpan">selector</span>(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger &#x3c; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.set" id="apidoc.element.gsap.TweenLite.set">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>set
        <span class="apidocSignatureSpan">(target, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (target, vars) {
			return new TweenLite(target, 0, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.<span class="apidocCodeKeywordSpan">set</span
>(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.to" id="apidoc.element.gsap.TweenLite.to">
        function <span class="apidocSignatureSpan">gsap.TweenLite.</span>to
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to = function (target, duration, vars) {
			return new TweenLite(target, duration, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.<span class="apidocCodeKeywordSpan">to</span>(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._internals" id="apidoc.module.gsap.TweenLite._internals">module gsap.TweenLite._internals</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._internals.blobDif" id="apidoc.element.gsap.TweenLite._internals.blobDif">
        function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>blobDif
        <span class="apidocSignatureSpan">(start, end, filter, pt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blobDif = function (start, end, filter, pt) {
				var a = [],
					charIndex = 0,
					s = &#x22;&#x22;,
					color = 0,
					startNums, endNums, num, i, l, nonNumbers, currentNum;
				a.start = start;
				a.end = end;
				start = a[0] = start + &#x22;&#x22;; //ensure values are strings
				end = a[1] = end + &#x22;&#x22;;
				if (filter) {
					filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
					start = a[0];
					end = a[1];
				}
				a.length = 0;
				startNums = start.match(_numbersExp) || [];
				endNums = end.match(_numbersExp) || [];
				if (pt) {
					pt._next = null;
					pt.blob = 1;
					a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
				}
				l = endNums.length;
				for (i = 0; i &#x3c; l; i++) {
					currentNum = endNums[i];
					nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex)-charIndex);
					s += (nonNumbers || !i) ? nonNumbers : &#x22;,&#x22;; //note: SVG spec allows omission of comma/space when a negative sign is wedged
between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert
 the comma just in case.
					charIndex += nonNumbers.length;
					if (color) { //sense rgba() values and round them.
						color = (color + 1) % 5;
					} else if (nonNumbers.substr(-5) === &#x22;rgba(&#x22;) {
						color = 1;
					}
					if (currentNum === startNums[i] || startNums.length &#x3c;= i) {
						s += currentNum;
					} else {
						if (s) {
							a.push(s);
							s = &#x22;&#x22;;
						}
						num = parseFloat(startNums[i]);
						a.push(num);
						a._firstPT = {_next: a._firstPT, t:a, p: a.length-1, s:num, c:((currentNum.charAt(1) === &#x22;=&#x22;) ? parseInt(currentNum.charAt
(0) + &#x22;1&#x22;, 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0, f:0, m:(color &#x26;&#x26; color &#x3c; 4) ? Math.round
 : 0};
						//note: we don&#x27;t set _prev because we&#x27;ll never need to remove individual PropTweens from this list.
					}
					charIndex += currentNum.length;
				}
				s += end.substr(charIndex);
				if (s) {
					a.push(s);
				}
				a.setRatio = _setRatio;
				return a;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._internals.isArray" id="apidoc.element.gsap.TweenLite._internals.isArray">
        function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>isArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (obj) {
					return obj != null &#x26;&#x26; (obj instanceof Array || (typeof(obj) === &#x22;object&#x22; &#x26;&#x26; !!obj.push &#x26;&#x26; toString.call(obj) === array));
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._internals.isSelector" id="apidoc.element.gsap.TweenLite._internals.isSelector">
        function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>isSelector
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSelector = function (v) {
				return (v &#x26;&#x26; v.length &#x26;&#x26; v !== window &#x26;&#x26; v[0] &#x26;&#x26; (v[0] === window || (v[0].nodeType &#x26;&#x26; v[0].style &#x26;&#x26; !v.nodeType))); //we cannot
 check &#x22;nodeType&#x22; if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like
 Firefox.
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._internals.lazyRender" id="apidoc.element.gsap.TweenLite._internals.lazyRender">
        function <span class="apidocSignatureSpan">gsap.TweenLite._internals.</span>lazyRender
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lazyRender = function () {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i &#x3e; -1) {
					tween = _lazyTweens[i];
					if (tween &#x26;&#x26; tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins" id="apidoc.module.gsap.TweenLite._plugins">module gsap.TweenLite._plugins</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.attr" id="apidoc.element.gsap.TweenLite._plugins.attr">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>attr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attr = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						this._parseTransform(target, v);
						continue;
					} else if (_transformMap[p] || p === &#x22;pivot&#x22;) {
						this._parseTransform(target, value);
						continue;
					}

					s = target.<span class="apidocCodeKeywordSpan">attr</span>(p);

					//Some of these properties are in place in order to conform with the standard PropTweens in TweenPlugins so that overwriting
 and roundProps occur properly. For example, f and r may seem unnecessary here, but they enable other functionality.
					//_next:*	next linked list node		[object]
					//t: 	*	target 						[object]
					//p:	*	property (camelCase)		[string]
					//s: 	*	starting value				[number]
					//c:	*	change value				[number]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.bezier" id="apidoc.element.gsap.TweenLite._plugins.bezier">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>bezier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bezier = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.colorProps" id="apidoc.element.gsap.TweenLite._plugins.colorProps">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>colorProps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorProps = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.css" id="apidoc.element.gsap.TweenLite._plugins.css">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>css
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">css = function () {
				TweenPlugin.call(this, &#x22;css&#x22;);
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.cssRule" id="apidoc.element.gsap.TweenLite._plugins.cssRule">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>cssRule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cssRule = function () {
				TweenPlugin.call(this, &#x22;cssRule&#x22;);
				this._overwriteProps.length = 0;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation" id="apidoc.element.gsap.TweenLite._plugins.directionalRotation">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>directionalRotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directionalRotation = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.easel" id="apidoc.element.gsap.TweenLite._plugins.easel">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>easel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">easel = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.endArray" id="apidoc.element.gsap.TweenLite._plugins.endArray">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>endArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endArray = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.modifiers" id="apidoc.element.gsap.TweenLite._plugins.modifiers">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>modifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modifiers = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.raphael" id="apidoc.element.gsap.TweenLite._plugins.raphael">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>raphael
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raphael = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.roundProps" id="apidoc.element.gsap.TweenLite._plugins.roundProps">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>roundProps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">roundProps = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.text" id="apidoc.element.gsap.TweenLite._plugins.text">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.</span>text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.attr.prototype" id="apidoc.module.gsap.TweenLite._plugins.attr.prototype">module gsap.TweenLite._plugins.attr.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.attr.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.attr.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween, index) {
			var p, end;
			if (typeof(target.setAttribute) !== &#x22;function&#x22;) {
				return false;
			}
			for (p in value) {
				end = value[p];
				if (typeof(end) === &#x22;function&#x22;) {
					end = end(index, target);
				}
				this._addTween(target, &#x22;setAttribute&#x22;, target.getAttribute(p) + &#x22;&#x22;, end + &#x22;&#x22;, p, false, p);
				this._overwriteProps.push(p);
			}
			return true;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.attr.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.attr.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.attr.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.directionalRotation.prototype" id="apidoc.module.gsap.TweenLite._plugins.directionalRotation.prototype">module gsap.TweenLite._plugins.directionalRotation.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween, index) {
			if (typeof(value) !== &#x22;object&#x22;) {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== &#x22;useRadians&#x22;) {
					end = value[p];
					if (typeof(end) === &#x22;function&#x22;) {
						end = end(index, target);
					}
					split = (end + &#x22;&#x22;).split(&#x22;_&#x22;);
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== &#x22;function&#x22;) ? target[p] : target[ ((p.indexOf(&#x22;set&#x22;) || typeof(target[&#x22;get&#x22; + p.
substr(3)]) !== &#x22;function&#x22;) ? p : &#x22;get&#x22; + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === &#x22;string&#x22; &#x26;&#x26; v.charAt(1) === &#x22;=&#x22;) ? start + parseInt(v.charAt(0) + &#x22;1&#x22;, 10) * Number(v
.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join(&#x22;_&#x22;);
						if (v.indexOf(&#x22;short&#x22;) !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif &#x3c; 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf(&#x22;_cw&#x22;) !== -1 &#x26;&#x26; dif &#x3c; 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf(&#x22;ccw&#x22;) !== -1 &#x26;&#x26; dif &#x3e; 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif &#x3e; min || dif &#x3c; -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype.setRatio" id="apidoc.element.gsap.TweenLite._plugins.directionalRotation.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.directionalRotation.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(ratio)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.easel.prototype" id="apidoc.module.gsap.TweenLite._plugins.easel.prototype">module gsap.TweenLite._plugins.easel.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.easel.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.easel.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween, index) {
			this._target = target;
			var p, pt, tint, colorMatrix, end, labels, i;
			for (p in value) {

				end = value[p];
				if (typeof(end) === &#x22;function&#x22;) {
					end = end(index, target);
				}
				if (p === &#x22;colorFilter&#x22; || p === &#x22;tint&#x22; || p === &#x22;tintAmount&#x22; || p === &#x22;exposure&#x22; || p === &#x22;brightness&#x22;) {
					if (!tint) {
						_parseColorFilter(target, value.colorFilter || value, this);
						tint = true;
					}

				} else if (p === &#x22;saturation&#x22; || p === &#x22;contrast&#x22; || p === &#x22;hue&#x22; || p === &#x22;colorize&#x22; || p === &#x22;colorizeAmount&#x22;) {
					if (!colorMatrix) {
						_parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);
						colorMatrix = true;
					}

				} else if (p === &#x22;frame&#x22;) {
					this._firstPT = pt = {_next:this._firstPT, t:target, p:&#x22;gotoAndStop&#x22;, s:target.currentFrame, f:true, n:&#x22;frame&#x22;, pr:0, type:
0, m:Math.round};
					if (typeof(end) === &#x22;string&#x22; &#x26;&#x26; end.charAt(1) !== &#x22;=&#x22; &#x26;&#x26; (labels = target.labels)) {
						for (i = 0; i &#x3c; labels.length; i++) {
							if (labels[i].label === end) {
								end = labels[i].position;
							}
						}
					}
					pt.c = (typeof(end) === &#x22;number&#x22;) ? end - pt.s : parseFloat((end+&#x22;&#x22;).split(&#x22;=&#x22;).join(&#x22;&#x22;));
					if (pt._next) {
						pt._next._prev = pt;
					}

				} else if (target[p] != null) {
					this._firstPT = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === &#x22;function&#x22;), n:p, pr:0, type:0};
					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf(&#x22;set&#x22;) || typeof(target[&#x22;get&#x22; + p.substr(3)]) !== &#x22;function&#x22;) ?
p : &#x22;get&#x22; + p.substr(3)) ]();
					pt.c = (typeof(end) === &#x22;number&#x22;) ? end - pt.s : (typeof(end) === &#x22;string&#x22;) ? parseFloat(end.split(&#x22;=&#x22;).join(&#x22;&#x22;)) : 0;

					if (pt._next) {
						pt._next._prev = pt;
					}
				}

			}
			return true;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.easel.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.easel.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.easel.prototype.setRatio" id="apidoc.element.gsap.TweenLite._plugins.easel.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.easel.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (v) {
			var pt = this._firstPT,
				min = 0.000001,
				val;
			while (pt) {
				val = pt.c * v + pt.s;
				if (pt.m) {
					val = pt.m(val, pt.t);
				} else if (val &#x3c; min &#x26;&#x26; val &#x3e; -min) {
					val = 0;
				}
				if (pt.f) {
					pt.t[pt.p](val);
				} else {
					pt.t[pt.p] = val;
				}
				pt = pt._next;
			}
			if (this._target.cacheID) {
				this._target.updateCache();
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.endArray.prototype" id="apidoc.module.gsap.TweenLite._plugins.endArray.prototype">module gsap.TweenLite._plugins.endArray.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype._mod" id="apidoc.element.gsap.TweenLite._plugins.endArray.prototype._mod">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_mod
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mod = function (lookup) {
			if (typeof(lookup.endArray) === &#x22;function&#x22;) {
				this._mod = lookup.endArray;
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			i = rp.length;
			while (--i &#x3e; -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t.<span class="apidocCodeKeywordSpan">_mod</span>(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.endArray.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween) {
			var i = value.length,
				a = this.a = [],
				start, end;
			this.target = target;
			this._mod = 0;
			if (!i) {
				return false;
			}
			while (--i &#x3e; -1) {
				start = target[i];
				end = value[i];
				if (start !== end) {
					a.push({i:i, s:start, c:end - start});
				}
			}
			return true;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.endArray.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.endArray.prototype.setRatio" id="apidoc.element.gsap.TweenLite._plugins.endArray.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.endArray.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(ratio)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (ratio) {
			var target = this.target,
				a = this.a,
				i = a.length,
				mod = this._mod,
				e, val;
			if (mod) {
				while (--i &#x3e; -1) {
					e = a[i];
					target[e.i] = mod(e.s + e.c * ratio, target);
				}
			} else {
				while (--i &#x3e; -1) {
					e = a[i];
					val = e.s + e.c * ratio;
					target[e.i] = (val &#x3c; 0.000001 &#x26;&#x26; val &#x3e; -0.000001) ? 0 : val;
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.modifiers.prototype" id="apidoc.module.gsap.TweenLite._plugins.modifiers.prototype">module gsap.TweenLite._plugins.modifiers.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._add" id="apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._add">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_add
        <span class="apidocSignatureSpan">(target, p, s, c, mod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_add = function (target, p, s, c, mod) {
			this._addTween(target, p, s, s + c, p, mod);
			this._overwriteProps.push(p);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._mod(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this.<span class="apidocCodeKeywordSpan">_add</span>(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._onInitAllProps" id="apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._onInitAllProps">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_onInitAllProps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitAllProps = function () {
					var tween = this._tween,
						lookup = this._vars,
						mpt = this,
						pt = tween._firstPT,
						val, next;
					while (pt) {
						next = pt._next; //record here, because it may get removed
						val = lookup[pt.n];
						if (pt.pg) {
							if (pt.t._propName === &#x22;css&#x22;) { //handle CSSPlugin uniquely (for performance, due to the fact that the values almost always
 are a concatenation of numbers and strings, like suffixes, and we don&#x27;t want to slow down the regular CSSPlugin setRatio() performance
 with conditional checks for if the value needs to be modded, so we pull any modding prop out and change it to a type:2 one that
 simply calls a setRatio() method where we encapsulate the modding and update all together. That way, it says in the main CSSProp
 linked list and just has some custom logic applied to it inside its setRatio())
								_modCSS(lookup, pt.t);
							} else if (pt.t !== mpt) { //don&#x27;t run modProps on modProps :)
								val = lookup[pt.t._propName];
								pt.t._mod((typeof(val) === &#x22;object&#x22;) ? val : lookup);
							}
						} else if (typeof(val) === &#x22;function&#x22;) {
							if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
								pt.t._applyPT.m = val;
							} else {
								this._add(pt.t, pt.p, pt.s, pt.c, val);
								//remove from linked list
								if (next) {
									next._prev = pt._prev;
								}
								if (pt._prev) {
									pt._prev._next = next;
								} else if (tween._firstPT === pt) {
									tween._firstPT = next;
								}
								pt._next = pt._prev = null;
								tween._propLookup[pt.n] = mpt;
							}
						}
						pt = next;
					}
					return false;
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.modifiers.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween) {
					this._tween = tween;
					this._vars = value;
					return true;
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.modifiers.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.modifiers.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.modifiers.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.raphael.prototype" id="apidoc.module.gsap.TweenLite._plugins.raphael.prototype">module gsap.TweenLite._plugins.raphael.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.raphael.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween) {
				if (!target.attr) { //raphael must have attr() method
					return false;
				}
				this._target = target;
				this._tween = tween;
				this._props = target._gsProps = target._gsProps || {};
				var p, s, v, pt, clr1, clr2, rel;

				for (p in value) {

					v = value[p];

					if (p === &#x22;transform&#x22;) {
						this._parseTransform(target, v);
						continue;
					} else if (_transformMap[p] || p === &#x22;pivot&#x22;) {
						this._parseTransform(target, value);
						continue;
					}

					s = target.attr(p);

					//Some of these properties are in place in order to conform with the standard PropTweens in TweenPlugins so that overwriting
 and roundProps occur properly. For example, f and r may seem unnecessary here, but they enable other functionality.
					//_next:*	next linked list node		[object]
					//t: 	*	target 						[object]
					//p:	*	property (camelCase)		[string]
					//s: 	*	starting value				[number]
					//c:	*	change value				[number]
					//f:	* 	is function					[boolean]
					//n:	*	name (for overwriting)		[string]
					//b:		beginning value				[string]
					//i:		intermediate value			[string]
					//e: 		ending value				[string]
					//r:	*	round						[boolean]
					//type:		0=normal, 1=color, 2=rgba, -1=non-tweening prop	[number]
					this._firstPT = pt = {_next:this._firstPT,
						t:this._props,
						p:p,
						b:s,
						f:false,
						n:&#x22;raphael_&#x22; + p,
						r:false,
						type:0};

					//color values must be split apart into their R, G, B (and sometimes alpha) values and tweened independently.
					if (p === &#x22;fill&#x22; || p === &#x22;stroke&#x22;) {
						clr1 = _parseColor(s);
						clr2 = _parseColor(v);
						pt.e = v;
						pt.s = Number(clr1[0]);				//red starting value
						pt.c = Number(clr2[0]) - pt.s;		//red change
						pt.gs = Number(clr1[1]);			//green starting value
						pt.gc = Number(clr2[1]) - pt.gs;	//green change
						pt.bs = Number(clr1[2]);			//blue starting value
						pt.bc = Number(clr2[2]) - pt.bs;	//blue change
						if (clr1.length &#x3e; 3 || clr2.length &#x3e; 3) { //detect an rgba() value
							pt.as = (clr1.length &#x3c; 4) ? 1 : Number(clr1[3]);
							pt.ac = ((clr2.length &#x3c; 4) ? 1 : Number(clr2[3])) - pt.as;
							pt.type = 2; //2 = rgba() tween
						} else {
							pt.type = 1; //1 = color tween, -1 = no tween, just set the value at the end because there&#x27;s no changes
						}

					} else {

						s = (typeof(s) === &#x22;string&#x22;) ? parseFloat(s.replace(_NaNExp, &#x22;&#x22;)) : Number(s);

						if (typeof(v) === &#x22;string&#x22;) {
							rel = (v.charAt(1) === &#x22;=&#x22;);
							v = parseFloat(v.replace(_NaNExp, &#x22;&#x22;));
						} else {
							rel = false;
						}

						pt.e = (v || v === 0) ? (rel ? v + s : v) : value[p]; //ensures that any += or -= prefixes are taken care of.

						if ((s || s === 0) &#x26;&#x26; (v || v === 0) &#x26;&#x26; (pt.c = (rel ? v : v - s))) { //faster than isNaN(). Also, we set pt.c (change) here
 because if it&#x27;s 0, we&#x27;ll just treat it like a non-tweening value. can&#x27;t do (v !== start) because if it&#x27;s a relative value and the
 CHANGE is identical to the START, the condition will fail unnecessarily.
							pt.s = s;
						} else {
							pt.type = -1;
							pt.i = value[p]; //intermediate value is typically the same as the end value.
							pt.s = pt.c = 0;
						}

					}

					this._overwriteProps.push(&#x22;raphael_&#x22; + p);
					if (pt._next) {
						pt._next._prev = pt;
					}
				}

				return true;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype._parseTransform" id="apidoc.element.gsap.TweenLite._plugins.raphael.prototype._parseTransform">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>_parseTransform
        <span class="apidocSignatureSpan">(t, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseTransform = function (t, v) {
		if (this._transform) { return; } //only need to parse the transform once, and only if the browser supports it.

		var m1 = this._transform = _getTransform(t, true),
			min = 0.000001,
			m2, skewY, p, pt, copy, dx, dy, mtx, pivot;

		if (typeof(v) === &#x22;object&#x22;) { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)

			m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
				  scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
				  tx:_parseVal(v.tx, m1.tx),
				  ty:_parseVal(v.ty, m1.ty)};

			if (v.shortRotation != null) {
				m2.rotation = (typeof(v.shortRotation) === &#x22;number&#x22;) ? v.shortRotation * _DEG2RAD : _parseAngle(v.shortRotation, m1.rotation
);
				var dif = (m2.rotation - m1.rotation) % (Math.PI * 2);
				if (dif !== dif % Math.PI) {
					dif += Math.PI * ((dif &#x3c; 0) ? 2 : -2);
				}
				m2.rotation = m1.rotation + dif;

			} else {
				m2.rotation = (v.rotation == null) ? m1.rotation : (typeof(v.rotation) === &#x22;number&#x22;) ? v.rotation * _DEG2RAD : _parseAngle(v
.rotation, m1.rotation);
			}
			m2.skewX = (v.skewX == null) ? m1.skewX : (typeof(v.skewX) === &#x22;number&#x22;) ? v.skewX * _DEG2RAD : _parseAngle(v.skewX, m1.skewX
);

			//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still
record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always
 act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can&#x27;t remember that
 skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees
.
			m2.skewY = (v.skewY == null) ? m1.skewY : (typeof(v.skewY) === &#x22;number&#x22;) ? v.skewY * _DEG2RAD : _parseAngle(v.skewY, m1.skewY
);
			if ((skewY = m2.skewY - m1.skewY)) {
				m2.skewX += skewY;
				m2.rotation += skewY;
			}
			//don&#x27;t allow rotation/skew values to be a SUPER small decimal because when they&#x27;re translated back to strings for setting the
 css property, the browser reports them in a funky way, like 1-e7. Of course we could use toFixed() to resolve that issue but that
 hurts performance quite a bit with all those function calls on every frame, plus it is virtually impossible to discern values that
 small visually (nobody will notice changing a rotation of 0.0000001 to 0, so the performance improvement is well worth it).
			if (m2.skewY &#x3c; min) if (m2.skewY &#x3e; -min) {
				m2.skewY = 0;
			}
			if (m2.skewX &#x3c; min) if (m2.skewX &#x3e; -min) {
				m2.skewX = 0;
			}
			if (m2.rotation &#x3c; min) if (m2.rotation &#x3e; -min) {
				m2.rotation = 0;
			}

			pivot = v.localPivot || v.globalPivot;

			if (typeof(pivot) === &#x22;string&#x22;) {
				copy = pivot.split(&#x22;,&#x22;);
				dx = Number(copy[0]);
				dy = Number(copy[1]);
			} else if (typeof(pivot) === &#x22;object&#x22;) {
				dx = Number(pivot.x);
				dy = Number(pivot.y);
			} else if (v.localPivot) {
				copy = t.getBBox(true);
				dx = copy.width / 2;
				dy = copy.height / 2;
			} else {
				copy = t.getBBox();
				dx = copy.x + copy.width / 2;
				dy = copy.y + copy.height / 2;
			}

			if (v.localPivot) {
				mtx = t.matrix;
				dx += t.attr(&#x22;x&#x22;);
				dy += t.attr(&#x22;y&#x22;);
				this._pxl = dx;
				this._pyl = dy;
				this._pxg = dx * mtx.a + dy * mtx.c + mtx.e - m1.tx;
				this._pyg = dx * mtx.b + dy * mtx.d + mtx.f - m1.ty;
			} else {
				mtx = t.matrix.invert();
				this._pxl = dx * mtx.a + dy * mtx.c + mtx.e;
				this._pyl = dx * mtx.b + dy * mtx.d + mtx.f;
				this._pxg = dx - m1.tx;
				this._pyg = dy - m1.ty;
			}

		} else if (typeof(v) === &#x22;string&#x22;) { //for values like transform:&#x22;rotate(60deg) scale(0.5, 0.8)&#x22;
			copy = this._target.transform();
			t.transform(v);
			m2 = _getTransform(t, false);
			t.transform(copy);
		} else {
			return;
		}

		for (p in _transformMap) {
			if (m1[p] !== m2[p]) if (p !== &#x22;shortRotation&#x22;) if (p !== &#x22;scale&#x22;) {
				this._firstPT = pt = {_next:this._firstPT, t:m1, p:p, s:m1[p], c:m2[p] - m1[p], n:p, f:fal ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				var p, s, v, pt, clr1, clr2, rel;

				for (p in value) {

					v = value[p];

					if (p === &#x22;transform&#x22;) {
						this.<span class="apidocCodeKeywordSpan">_parseTransform</span>(target, v);
						continue;
					} else if (_transformMap[p] || p === &#x22;pivot&#x22;) {
						this._parseTransform(target, value);
						continue;
					}

					s = target.attr(p);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.raphael.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.raphael.prototype.setRatio" id="apidoc.element.gsap.TweenLite._plugins.raphael.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.raphael.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (v) {
				var pt = this._firstPT, val;

				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					}
					if (!pt.type) {
						pt.t[pt.p] = val;
					} else if (pt.type === 1) { //rgb()
						pt.t[pt.p] = &#x22;rgb(&#x22; + (val &#x3e;&#x3e; 0) + &#x22;, &#x22; + ((pt.gs + (v * pt.gc)) &#x3e;&#x3e; 0) + &#x22;, &#x22; + ((pt.bs + (v * pt.bc)) &#x3e;&#x3e; 0) + &#x22;)&#x22;;
					} else if (pt.type === 2) { //rgba()
						pt.t[pt.p] = &#x22;rgba(&#x22; + (val &#x3e;&#x3e; 0) + &#x22;, &#x22; + ((pt.gs + (v * pt.gc)) &#x3e;&#x3e; 0) + &#x22;, &#x22; + ((pt.bs + (v * pt.bc)) &#x3e;&#x3e; 0) + &#x22;, &#x22; + (pt
.as + (v * pt.ac)) + &#x22;)&#x22;;
					} else if (pt.type === -1) { //non-tweening
						pt.t[pt.p] = pt.i;
					}
					pt = pt._next;
				}

				this._target.attr(this._props);

				//apply transform values like x, y, scaleX, scaleY, rotation, skewX, or skewY. We do these after looping through all the PropTweens
 because those are where the changes are made to scaleX/scaleY/rotation/skewX/skewY/x/y.
				if (this._transform) {
					pt = this._transform; //to improve speed and reduce size, reuse the pt variable as an alias to the _transform property
					var ang = pt.rotation,
						skew = ang - pt.skewX,
						a = Math.cos(ang) * pt.scaleX,
						b = Math.sin(ang) * pt.scaleX,
						c = Math.sin(skew) * -pt.scaleY,
						d = Math.cos(skew) * pt.scaleY,
						min = 0.000001,
						pxl = this._pxl,
						pyl = this._pyl;

					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the &#x22;e-&#x22; towards the end) and would
 render the object slightly off. So we round to 0 in these cases for both b and c. The conditional logic here is faster than calling
 Math.abs().
					if (b &#x3c; min) if (b &#x3e; -min) {
						b = 0;
					}
					if (c &#x3c; min) if (c &#x3e; -min) {
						c = 0;
					}
					pt.ox = this._pxg - (pxl * a + pyl * c); //we must record the offset x/y that we&#x27;re making from the regular tx/ty (matrix.e
 and f) so that we can correctly interpret positional data in _getTransform(). See note there on tx and ox.
					pt.oy = this._pyg - (pxl * b + pyl * d);
					this._target.transform(&#x22;m&#x22; + a + &#x22;,&#x22; + b + &#x22;,&#x22; + c + &#x22;,&#x22; + d + &#x22;,&#x22; + (pt.tx + pt.ox) + &#x22;,&#x22; + (pt.ty + pt.oy));
				}

			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.roundProps.prototype" id="apidoc.module.gsap.TweenLite._plugins.roundProps.prototype">module gsap.TweenLite._plugins.roundProps.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._add" id="apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._add">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_add
        <span class="apidocSignatureSpan">(target, p, s, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_add = function (target, p, s, c) {
			this._addTween(target, p, s, s + c, p, Math.round);
			this._overwriteProps.push(p);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._mod(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this.<span class="apidocCodeKeywordSpan">_add</span>(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._onInitAllProps" id="apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._onInitAllProps">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_onInitAllProps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitAllProps = function () {
			var tween = this._tween,
				rp = (tween.vars.roundProps.join) ? tween.vars.roundProps : tween.vars.roundProps.split(&#x22;,&#x22;),
				i = rp.length,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				prop, pt, next;
			while (--i &#x3e; -1) {
				lookup[rp[i]] = Math.round;
			}
			i = rp.length;
			while (--i &#x3e; -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._mod(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.roundProps.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween) {
					this._tween = tween;
					return true;
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.roundProps.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.roundProps.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.roundProps.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite._plugins.text.prototype" id="apidoc.module.gsap.TweenLite._plugins.text.prototype">module gsap.TweenLite._plugins.text.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.text.prototype._onInitTween" id="apidoc.element.gsap.TweenLite._plugins.text.prototype._onInitTween">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>_onInitTween
        <span class="apidocSignatureSpan">(target, value, tween, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onInitTween = function (target, value, tween, index) {
					var i = target.nodeName.toUpperCase(),
						shrt;
					if (typeof(value) === &#x22;function&#x22;) {
						value = value(index, target);
					}
					this._svg = (target.getBBox &#x26;&#x26; (i === &#x22;TEXT&#x22; || i === &#x22;TSPAN&#x22;));
					if (!(&#x22;innerHTML&#x22; in target) &#x26;&#x26; !this._svg) {
						return false;
					}
					this._target = target;
					if (typeof(value) !== &#x22;object&#x22;) {
						value = {value:value};
					}
					if (value.value === undefined) {
						this._text = this._original = [&#x22;&#x22;];
						return true;
					}
					this._delimiter = value.delimiter || &#x22;&#x22;;
					this._original = _getText(target).replace(/\s+/g, &#x22; &#x22;).split(this._delimiter);
					this._text = value.value.replace(/\s+/g, &#x22; &#x22;).split(this._delimiter);
					this._runBackwards = (tween.vars.runBackwards === true);
					if (this._runBackwards) {
						i = this._original;
						this._original = this._text;
						this._text = i;
					}
					if (typeof(value.newClass) === &#x22;string&#x22;) {
						this._newClass = value.newClass;
						this._hasClass = true;
					}
					if (typeof(value.oldClass) === &#x22;string&#x22;) {
						this._oldClass = value.oldClass;
						this._hasClass = true;
					}
					i = this._original.length - this._text.length;
					shrt = (i &#x3c; 0) ? this._original : this._text;
					this._fillChar = value.fillChar || (value.padSpace ? &#x22;&#x26;nbsp;&#x22; : &#x22;&#x22;);
					if (i &#x3c; 0) {
						i = -i;
					}
					while (--i &#x3e; -1) {
						shrt.push(this._fillChar);
					}
					return true;
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -
1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]()).<span class="apidocCodeKeywordSpan">_onInitTween</span>(target
, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.text.prototype.constructor" id="apidoc.element.gsap.TweenLite._plugins.text.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite._plugins.text.prototype.setRatio" id="apidoc.element.gsap.TweenLite._plugins.text.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.TweenLite._plugins.text.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(ratio)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (ratio) {
					if (ratio &#x3e; 1) {
						ratio = 1;
					} else if (ratio &#x3c; 0) {
						ratio = 0;
					}
					if (this._runBackwards) {
						ratio = 1 - ratio;
					}
					var l = this._text.length,
						i = (ratio * l + 0.5) | 0,
						applyNew, applyOld, str;
					if (this._hasClass) {
						applyNew = (this._newClass &#x26;&#x26; i !== 0);
						applyOld = (this._oldClass &#x26;&#x26; i !== l);
						str = (applyNew ? &#x22;&#x3c;span class=&#x27;&#x22; + this._newClass + &#x22;&#x27;&#x3e;&#x22; : &#x22;&#x22;) + this._text.slice(0, i).join(this._delimiter) + (applyNew
 ? &#x22;&#x3c;/span&#x3e;&#x22; : &#x22;&#x22;) + (applyOld ? &#x22;&#x3c;span class=&#x27;&#x22; + this._oldClass + &#x22;&#x27;&#x3e;&#x22; : &#x22;&#x22;) + this._delimiter + this._original.slice(i).join(
this._delimiter) + (applyOld ? &#x22;&#x3c;/span&#x3e;&#x22; : &#x22;&#x22;);
					} else {
						str = this._text.slice(0, i).join(this._delimiter) + this._delimiter + this._original.slice(i).join(this._delimiter);
					}
					if (this._svg) { //SVG text elements don&#x27;t have an &#x22;innerHTML&#x22; in Microsoft browsers.
						this._target.textContent = str;
					} else {
						this._target.innerHTML = (this._fillChar === &#x22;&#x26;nbsp;&#x22; &#x26;&#x26; str.indexOf(&#x22;  &#x22;) !== -1) ? str.split(&#x22;  &#x22;).join(&#x22;&#x26;nbsp;&#x26;nbsp;&#x22;) :
str;
					}
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenLite.prototype" id="apidoc.module.gsap.TweenLite.prototype">module gsap.TweenLite.prototype</a></h1>












    <h2>
        <a href="#apidoc.element.gsap.TweenLite.prototype._enabled" id="apidoc.element.gsap.TweenLite.prototype._enabled">
        function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_enabled
        <span class="apidocSignatureSpan">(enabled, ignoreTimeline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled &#x26;&#x26; this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i &#x3e; -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? &#x22;_onEnable&#x22; : &#x22;_onDisable&#x22;), this);
			}
			return false;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() &#x3e; value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the
 current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let
it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue
 that it should jump to its end state, that&#x27;s not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime &#x26;&#x26; tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl.<span class="apidocCodeKeywordSpan">_enabled</span>(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.prototype._init" id="apidoc.element.gsap.TweenLite.prototype._init">
        function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_init = function () {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars, l;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we&#x27;ve run a startAt previously (when the tween instantiated), we should revert it so that
 the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:&#x22;+=100&#x22;}, {x:&#x22;-=
100&#x22;}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500
}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate &#x26;&#x26; v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop
).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time &#x3e; 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn&#x27;t revert when their
parent timeline&#x27;s playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn
&#x27;t be directly correlated to this tween&#x27;s startTime. Imagine setting up a complex animation where the beginning states of various
 objects are rendered immediately but the tween doesn&#x27;t happen for quite some time - if we revert to the starting values as soon
 as the playhead goes backward past the tween&#x27;s startTime, it will throw things off visually. Reversion should only happen in TimelineLite
/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn&#x27;t occur until the tween actually begins. Otherwise, if you
 create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one
 created would overwrite the first ones because they didn&#x27;t get placed into the timeline yet before the first render occurs and
kicks in overwriting.
					}
				}
			} else if (v.runBackwards &#x26;&#x26; dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don&#x27;t want overwriting to occur yet
 (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should
 render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be
 true but the initial forced-render gets skipped, so there&#x27;s no need to force the render in this context when the _time is greater
 than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could
 fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === &#x22;autoCSS&#x22;) {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = &#x22;isFromStart&#x22;; //we tag the tween with as &#x22;isFromStart&#x22; so that if [inside a plugin] we need to only do something
 at the very END of a tween, we have a way of identifying this tween as merely the one that&#x27;s setting the beginning values for a
 &#x22;from()&#x22; tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from
(...{height:100, clearProps:&#x22;height&#x22;, delay:1}) would wi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					}
					pt.overwrite = 0;
					pt.data = &#x22;isFromStart&#x22;; //we tag the tween with as &#x22;isFromStart&#x22; so that if [inside a plugin] we need
to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that&#x27;s setting the
 beginning values for a &#x22;from()&#x22; tween. For example, clearProps in CSSPlugin should only get applied at the very END of
 a tween and without this tag, from(...{height:100, clearProps:&#x22;height&#x22;, delay:1}) would wipe the height at the beginning
 of the tween and after 1 second, it&#x27;d kick back in.
					pt.lazy = (immediate &#x26;&#x26; v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we&#x27;re not specifically instructed
 to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately
 would push them to completion which is wasteful in that case - we&#x27;d have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt.<span class="apidocCodeKeywordSpan">_init</span>(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we&#x27;ll always
manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.prototype._initProps" id="apidoc.element.gsap.TweenLite.prototype._initProps">
        function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_initProps
        <span class="apidocSignatureSpan">(target, propLookup, siblings, overwrittenProps, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initProps = function (target, propLookup, siblings, overwrittenProps, index) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven&#x27;t rendered yet, we&#x27;ve got to force the render
 so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the
 end)
			}

			if (!this.vars.css) if (target.style) if (target !== window &#x26;&#x26; target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false
) { //it&#x27;s so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that
&#x27;s what is intended (a convenience so that users don&#x27;t have to wrap things in css:{}, although we still recommend it for a slight
 performance boost and better specificity). Note: we cannot check &#x22;nodeType&#x22; on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push &#x26;&#x26; _isArray(v))) if (v.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] &#x26;&#x26; (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					//m - mod           [function | 0]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:&#x22;setRatio&#x22;, s:0, c:1, f:1, n:p, pg:1, pr:plugin._priority, m:0};
					i = plugin._overwriteProps.length;
					while (--i &#x3e; -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}
					if (pt._next) {
						pt._next._prev = pt;
					}

				} else {
					propLookup[p] = _addPropTween.call(this, target, p, &#x22;get&#x22;, v, p, 0, null, this.vars.stringFilter, index);
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this
 tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._overwrite &#x3e; 1) if (this._firstPT) if (siblings.length &#x3e; 1) if (_applyOverwrite(target, this, propLookup, this._overwrite
, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._firstPT) if ((this.vars.lazy !== false &#x26;&#x26; this._duration) || (this.vars.lazy &#x26;&#x26; !this._duration)) { //zero duration
 tweens don&#x27;t lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				l = this._targets.length;
				for (i = 0; i &#x3c; l; i++) {
					if ( this.<span class="apidocCodeKeywordSpan">_initProps</span>( this._targets[i], (this._propLookup[i] = {}), this._siblings
[i], (op ? op[i] : null), i) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.prototype._kill" id="apidoc.element.gsap.TweenLite.prototype._kill">
        function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>_kill
        <span class="apidocSignatureSpan">(vars, target, overwritingTween)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_kill = function (vars, target, overwritingTween) {
			if (vars === &#x22;all&#x22;) {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== &#x22;string&#x22;) ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var simultaneousOverwrite = (overwritingTween &#x26;&#x26; this._time &#x26;&#x26; overwritingTween._startTime === this._startTime &#x26;&#x26; this._timeline
 === overwritingTween._timeline),
				i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
				i = target.length;
				while (--i &#x3e; -1) {
					if (this._kill(vars, target[i], overwritingTween)) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i &#x3e; -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : &#x22;all&#x22;;
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : &#x22;all&#x22;;
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps &#x26;&#x26; overwrittenProps !== &#x22;all&#x22; &#x26;&#x26; vars !== propLookup &#x26;&#x26; (typeof(vars) !== &#x22;object&#x22; || !
vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official
 overwritten property (like in BezierPlugin)
					if (overwritingTween &#x26;&#x26; (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if ((killed || !vars) &#x26;&#x26; !_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that
 means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (simultaneousOverwrite) { //if another tween overwrites this one and they both start at exactly the same time, yet this
 tween has already rendered once (for example, at 0.001) because it&#x27;s first in the queue, we should revert the values to where they
 were at 0 so that the starting values aren&#x27;t contaminated on the overwriting tween.
								if (pt.f) {
									pt.t[pt.p](pt.s);
								} else {
									pt.t[pt.p] = pt.s;
								}
								changed = true;
							}
							if (pt.pg &#x26;&#x26; pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT &#x26;&#x26; this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there
&#x27;s a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain
active and fire its onComplete even though there aren&#x27;t any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (!vars &#x26;&#x26; !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i &#x3e; -1) {
				if (tweens[i].<span class="apidocCodeKeywordSpan">_kill</span>(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.prototype.constructor" id="apidoc.element.gsap.TweenLite.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>constructor
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)

				if (target == null) {
					throw &#x22;Cannot tween a null target.&#x22;;
				}

				this.target = target = (typeof(target) !== &#x22;string&#x22;) ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length &#x26;&#x26; target !== window &#x26;&#x26; target[0] &#x26;&#x26; (target[0] === window || (target[0].nodeType
 &#x26;&#x26; target[0].style &#x26;&#x26; !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === &#x22;number
&#x22;) ? overwrite &#x3e;&#x3e; 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push &#x26;&#x26; _isArray(target))) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
					this._targets = targets = _slice(target);  //don&#x27;t use Array.prototype.slice.call(target, 0) because that doesn&#x27;t work in IE8
 with a NodeList that&#x27;s returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i &#x3c; targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === &#x22;string&#x22;) {
							targ = targets[i--] = TweenLite.selector(targ); //in case it&#x27;s an array of strings
							if (typeof(targ) === &#x22;string&#x22;) {
								targets.splice(i+1, 1); //to avoid an endless loop (can&#x27;t imagine why the selector would return a string, but just in case
)
							}
							continue;
						} else if (targ.length &#x26;&#x26; targ !== window &#x26;&#x26; targ[0] &#x26;&#x26; (targ[0] === window || (targ[0].nodeType &#x26;&#x26; targ[0].style &#x26;&#x26; !targ
.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level
 and pull things out if necessary. Also note that &#x3c;select&#x3e; elements pass all the criteria regarding length and the first child having
 style, so we must also check to ensure the target isn&#x27;t an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length &#x3e; 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length &#x3e; 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 &#x26;&#x26; this._delay === 0 &#x26;&#x26; this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() &#x22;force&#x22; parameter to true because we want to allow
 lazying by default (using the &#x22;force&#x22; parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.prototype.invalidate" id="apidoc.element.gsap.TweenLite.prototype.invalidate">
        function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>invalidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidate = function () {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent(&#x22;_onDisable&#x22;, this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() &#x22;force&#x22; parameter to true because we want to allow
 lazying by default (using the &#x22;force&#x22; parameter always forces an immediate full render)
				this.render(Math.min(0, -this._delay)); //in case delay is negative.
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.<span class="apidocCodeKeywordSpan">invalidate</span>();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenLite.prototype.render" id="apidoc.element.gsap.TweenLite.prototype.render">
        function <span class="apidocSignatureSpan">gsap.TweenLite.prototype.</span>render
        <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time &#x3e;= duration - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should
 be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive time to a negative time
), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime &#x3c; 0 || (time &#x3c;= 0 &#x26;&#x26; time &#x3e;= -0.0000001) || (prevRawPrevTime === _tinyNum &#x26;&#x26; this.data !== &#x22;isPause&#x22;))
if (prevRawPrevTime !== time) { //note: when this.data is &#x22;isPause&#x22;, it&#x27;s a callback added by addPause() on a timeline that we should
 not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn&#x27;t pause.
						force = true;
						if (prevRawPrevTime &#x3e; _tinyNum) {
							callback = &#x22;onReverseComplete&#x22;;
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead
 arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the
 playhead moves again (next time), it&#x27;ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered
 in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine
 doing a timeline.seek(0) and there&#x27;s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing
will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively
expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable
 which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time &#x3c; 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 &#x26;&#x26; prevRawPrevTime &#x3e; 0)) {
					callback = &#x22;onReverseComplete&#x22;;
					isComplete = this._reversed;
				}
				if (time &#x3c; 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end v ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (curTime !== this._time || (this._paused &#x26;&#x26; !prevPaused)) { //in case a tween pauses or seeks the timeline when
 rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime &#x3c;= curTime &#x26;&#x26; !tween._paused &#x26;&#x26; !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.<span class="apidocCodeKeywordSpan">render</span>((time - tween._startTime) * tween._timeScale, suppressEvents, force
);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale
), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
...</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenMax" id="apidoc.module.gsap.TweenMax">module gsap.TweenMax</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenMax.TweenMax" id="apidoc.element.gsap.TweenMax.TweenMax">
        function <span class="apidocSignatureSpan">gsap.</span>TweenMax
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenMax = function (target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.BackIn" id="apidoc.element.gsap.TweenMax.BackIn">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BackIn
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackIn = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.BackInOut" id="apidoc.element.gsap.TweenMax.BackInOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BackInOut
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackInOut = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.BackOut" id="apidoc.element.gsap.TweenMax.BackOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BackOut
        <span class="apidocSignatureSpan">(overshoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BackOut = function (overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.BezierPlugin" id="apidoc.element.gsap.TweenMax.BezierPlugin">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BezierPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BezierPlugin = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.BounceIn" id="apidoc.element.gsap.TweenMax.BounceIn">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BounceIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.BounceInOut" id="apidoc.element.gsap.TweenMax.BounceInOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BounceInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.BounceOut" id="apidoc.element.gsap.TweenMax.BounceOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>BounceOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BounceOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.CSSPlugin" id="apidoc.element.gsap.TweenMax.CSSPlugin">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CSSPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CSSPlugin = function () {
				TweenPlugin.call(this, &#x22;css&#x22;);
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.CSSRulePlugin" id="apidoc.element.gsap.TweenMax.CSSRulePlugin">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CSSRulePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CSSRulePlugin = function () {
				TweenPlugin.call(this, &#x22;cssRule&#x22;);
				this._overwriteProps.length = 0;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.CircIn" id="apidoc.element.gsap.TweenMax.CircIn">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CircIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.CircInOut" id="apidoc.element.gsap.TweenMax.CircInOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CircInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.CircOut" id="apidoc.element.gsap.TweenMax.CircOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>CircOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CircOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.ColorPropsPlugin" id="apidoc.element.gsap.TweenMax.ColorPropsPlugin">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ColorPropsPlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ColorPropsPlugin = function () {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Cubic" id="apidoc.element.gsap.TweenMax.Cubic">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Cubic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Cubic = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Ease" id="apidoc.element.gsap.TweenMax.Ease">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Ease
        <span class="apidocSignatureSpan">(func, extraParams, type, power)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Ease = function (func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.ElasticIn" id="apidoc.element.gsap.TweenMax.ElasticIn">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ElasticIn
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticIn = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.ElasticInOut" id="apidoc.element.gsap.TweenMax.ElasticInOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ElasticInOut
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticInOut = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.ElasticOut" id="apidoc.element.gsap.TweenMax.ElasticOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ElasticOut
        <span class="apidocSignatureSpan">(amplitude, period)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ElasticOut = function (amplitude, period) {
					this._p1 = (amplitude &#x3e;= 1) ? amplitude : 1; //note: if amplitude is &#x3c; 1, we simply adjust the period for a more natural feel
. Otherwise the math doesn&#x27;t work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude &#x3c; 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.ExpoIn" id="apidoc.element.gsap.TweenMax.ExpoIn">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ExpoIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.ExpoInOut" id="apidoc.element.gsap.TweenMax.ExpoInOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ExpoInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.ExpoOut" id="apidoc.element.gsap.TweenMax.ExpoOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>ExpoOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExpoOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Linear" id="apidoc.element.gsap.TweenMax.Linear">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Linear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Linear = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Power0" id="apidoc.element.gsap.TweenMax.Power0">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power0
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power0 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Power1" id="apidoc.element.gsap.TweenMax.Power1">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power1 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Power2" id="apidoc.element.gsap.TweenMax.Power2">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power2 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Power3" id="apidoc.element.gsap.TweenMax.Power3">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power3
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power3 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Power4" id="apidoc.element.gsap.TweenMax.Power4">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Power4
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Power4 = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Quad" id="apidoc.element.gsap.TweenMax.Quad">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Quad
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Quad = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Quart" id="apidoc.element.gsap.TweenMax.Quart">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Quart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Quart = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Quint" id="apidoc.element.gsap.TweenMax.Quint">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Quint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Quint = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.RoughEase" id="apidoc.element.gsap.TweenMax.RoughEase">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>RoughEase
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RoughEase = function (vars) {
			vars = vars || {};
			var taper = vars.taper || &#x22;none&#x22;,
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === &#x22;number&#x22;) ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i &#x3e; -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === &#x22;none&#x22;) {
					bump = strength;
				} else if (taper === &#x22;out&#x22;) {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === &#x22;in&#x22;) {
					bump = x * x * strength;
				} else if (x &#x3c; 0.5) {  //&#x22;both&#x22; (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//&#x22;both&#x22; (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y &#x3e; 1) {
						y = 1;
					} else if (y &#x3c; 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i &#x3e; -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.SineIn" id="apidoc.element.gsap.TweenMax.SineIn">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SineIn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineIn = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.SineInOut" id="apidoc.element.gsap.TweenMax.SineInOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SineInOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineInOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.SineOut" id="apidoc.element.gsap.TweenMax.SineOut">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SineOut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SineOut = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.SlowMo" id="apidoc.element.gsap.TweenMax.SlowMo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SlowMo
        <span class="apidocSignatureSpan">(linearRatio, power, yoyoMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SlowMo = function (linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio &#x3e; 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.SteppedEase" id="apidoc.element.gsap.TweenMax.SteppedEase">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>SteppedEase
        <span class="apidocSignatureSpan">(steps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SteppedEase = function (steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.Strong" id="apidoc.element.gsap.TweenMax.Strong">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>Strong
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Strong = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.TimelineLite" id="apidoc.element.gsap.TweenMax.TimelineLite">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TimelineLite
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimelineLite = function (vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join(&#x22;&#x22;).indexOf(&#x22;{self}&#x22;) !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.TimelineMax" id="apidoc.element.gsap.TweenMax.TimelineMax">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TimelineMax
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimelineMax = function (vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.TweenLite" id="apidoc.element.gsap.TweenMax.TweenLite">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TweenLite
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenLite = function (target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)

				if (target == null) {
					throw &#x22;Cannot tween a null target.&#x22;;
				}

				this.target = target = (typeof(target) !== &#x22;string&#x22;) ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length &#x26;&#x26; target !== window &#x26;&#x26; target[0] &#x26;&#x26; (target[0] === window || (target[0].nodeType
 &#x26;&#x26; target[0].style &#x26;&#x26; !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === &#x22;number
&#x22;) ? overwrite &#x3e;&#x3e; 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push &#x26;&#x26; _isArray(target))) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
					this._targets = targets = _slice(target);  //don&#x27;t use Array.prototype.slice.call(target, 0) because that doesn&#x27;t work in IE8
 with a NodeList that&#x27;s returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i &#x3c; targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === &#x22;string&#x22;) {
							targ = targets[i--] = TweenLite.selector(targ); //in case it&#x27;s an array of strings
							if (typeof(targ) === &#x22;string&#x22;) {
								targets.splice(i+1, 1); //to avoid an endless loop (can&#x27;t imagine why the selector would return a string, but just in case
)
							}
							continue;
						} else if (targ.length &#x26;&#x26; targ !== window &#x26;&#x26; targ[0] &#x26;&#x26; (targ[0] === window || (targ[0].nodeType &#x26;&#x26; targ[0].style &#x26;&#x26; !targ
.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level
 and pull things out if necessary. Also note that &#x3c;select&#x3e; elements pass all the criteria regarding length and the first child having
 style, so we must also check to ensure the target isn&#x27;t an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length &#x3e; 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length &#x3e; 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 &#x26;&#x26; this._delay === 0 &#x26;&#x26; this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() &#x22;force&#x22; parameter to true because we want to allow
 lazying by default (using the &#x22;force&#x22; parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.TweenPlugin" id="apidoc.element.gsap.TweenMax.TweenPlugin">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>TweenPlugin
        <span class="apidocSignatureSpan">(props, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenPlugin = function (props, priority) {
					this._overwriteProps = (props || &#x22;&#x22;).split(&#x22;,&#x22;);
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.allFrom" id="apidoc.element.gsap.TweenMax.allFrom">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>allFrom
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.allFromTo" id="apidoc.element.gsap.TweenMax.allFromTo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>allFromTo
        <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.allTo" id="apidoc.element.gsap.TweenMax.allTo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>allTo
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt &#x26;&#x26; vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === &#x22;string&#x22;) {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger &#x3c; 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i &#x3c;= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l &#x26;&#x26; onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.delayedCall" id="apidoc.element.gsap.TweenMax.delayedCall">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>delayedCall
        <span class="apidocSignatureSpan">(delay, callback, params, scope, useFrames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayedCall = function (delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete
:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope
) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.<span class="apidocCodeKeywordSpan">delayedCall</span>(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time &#x26;&#x26; !this._paused);
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.from" id="apidoc.element.gsap.TweenMax.from">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>from
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).<span class="apidocCodeKeywordSpan">from</span>(
target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.fromTo" id="apidoc.element.gsap.TweenMax.fromTo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>fromTo
        <span class="apidocSignatureSpan">(target, duration, fromVars, toVars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromTo = function (target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.<span class="apidocCodeKeywordSpan">fromTo</span>(target, duration, fromVars, toVars), position
) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope,
smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === &#x22;string&#x22;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.getAllTweens" id="apidoc.element.gsap.TweenMax.getAllTweens">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>getAllTweens
        <span class="apidocSignatureSpan">(includeTimelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllTweens = function (includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines
) );
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.getTweensOf" id="apidoc.element.gsap.TweenMax.getTweensOf">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>getTweensOf
        <span class="apidocSignatureSpan">(target, onlyActive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTweensOf = function (target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== &#x22;string&#x22;) ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) &#x26;&#x26; typeof(target[0]) !== &#x22;number&#x22;) {
				i = target.length;
				a = [];
				while (--i &#x3e; -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i &#x3e; -1) {
					t = a[i];
					j = i;
					while (--j &#x3e; -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i &#x3e; -1) {
					if (a[i]._gc || (onlyActive &#x26;&#x26; !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline
 completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.<span class="apidocCodeKeywordSpan">getTweensOf</span>(target);
			i = tweens.length;
			while (--i &#x3e; -1) {
				if (tweens[i].timeline === this || (nested &#x26;&#x26; this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.globalTimeScale" id="apidoc.element.gsap.TweenMax.globalTimeScale">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>globalTimeScale
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalTimeScale = function (value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can&#x27;t allow zero because it&#x27;ll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.isTweening" id="apidoc.element.gsap.TweenMax.isTweening">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>isTweening
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTweening = function (target) {
			return (TweenLite.getTweensOf(target, true).length &#x3e; 0);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.killAll" id="apidoc.element.gsap.TweenMax.killAll">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killAll
        <span class="apidocSignatureSpan">(complete, tweens, delayedCalls, timelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killAll = function (complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens &#x26;&#x26; delayedCalls &#x26;&#x26; timelines),
				isDC, tween, i;
			for (i = 0; i &#x3c; l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) &#x26;&#x26; delayedCalls) || (
tweens &#x26;&#x26; !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.killChildTweensOf" id="apidoc.element.gsap.TweenMax.killChildTweensOf">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killChildTweensOf
        <span class="apidocSignatureSpan">(parent, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killChildTweensOf = function (parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === &#x22;string&#x22;) {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i &#x3e; -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i &#x3c; l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.killDelayedCallsTo" id="apidoc.element.gsap.TweenMax.killDelayedCallsTo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killDelayedCallsTo
        <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killDelayedCallsTo = function (target, onlyActive, vars) {
			if (typeof(onlyActive) === &#x22;object&#x22;) {
				vars = onlyActive; //for backwards compatibility (before &#x22;onlyActive&#x22; parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i &#x3e; -1) {
				a[i]._kill(vars, target);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.killTweensOf" id="apidoc.element.gsap.TweenMax.killTweensOf">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>killTweensOf
        <span class="apidocSignatureSpan">(target, onlyActive, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">killTweensOf = function (target, onlyActive, vars) {
			if (typeof(onlyActive) === &#x22;object&#x22;) {
				vars = onlyActive; //for backwards compatibility (before &#x22;onlyActive&#x22; parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i &#x3e; -1) {
				a[i]._kill(vars, target);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.lagSmoothing" id="apidoc.element.gsap.TweenMax.lagSmoothing">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>lagSmoothing
        <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lagSmoothing = function (threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		TweenLite.version = &#x22;1.19.1&#x22;;
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = &#x22;auto&#x22;;
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.<span class="apidocCodeKeywordSpan">lagSmoothing</span>(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.pauseAll" id="apidoc.element.gsap.TweenMax.pauseAll">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>pauseAll
        <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseAll = function (tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.render" id="apidoc.element.gsap.TweenMax.render">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>render
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function () {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine
 refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame &#x3e;= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i &#x3e; -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they&#x27;re all paused, make the _timer sleep to reduce load on the
CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep &#x26;&#x26; !_rootFramesTimeline._first &#x26;&#x26; _ticker._listeners.tick.length === 1) {
						while (p &#x26;&#x26; p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (curTime !== this._time || (this._paused &#x26;&#x26; !prevPaused)) { //in case a tween pauses or seeks the timeline when
 rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime &#x3c;= curTime &#x26;&#x26; !tween._paused &#x26;&#x26; !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.<span class="apidocCodeKeywordSpan">render</span>((time - tween._startTime) * tween._timeScale, suppressEvents, force
);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale
), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.resumeAll" id="apidoc.element.gsap.TweenMax.resumeAll">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>resumeAll
        <span class="apidocSignatureSpan">(tweens, delayedCalls, timelines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resumeAll = function (tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.set" id="apidoc.element.gsap.TweenMax.set">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>set
        <span class="apidocSignatureSpan">(target, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (target, vars) {
			return new TweenMax(target, 0, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.<span class="apidocCodeKeywordSpan">set</span
>(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat &#x26;&#x26; _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.staggerFrom" id="apidoc.element.gsap.TweenMax.staggerFrom">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>staggerFrom
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.staggerFromTo" id="apidoc.element.gsap.TweenMax.staggerFromTo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>staggerFromTo
        <span class="apidocSignatureSpan">(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.staggerTo" id="apidoc.element.gsap.TweenMax.staggerTo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>staggerTo
        <span class="apidocSignatureSpan">(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">staggerTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt &#x26;&#x26; vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === &#x22;string&#x22;) {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger &#x3c; 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i &#x3c;= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l &#x26;&#x26; onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.<span class="apidocCodeKeywordSpan">staggerTo</span>(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams
, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope
) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false &#x26;&#x26; fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.to" id="apidoc.element.gsap.TweenMax.to">
        function <span class="apidocSignatureSpan">gsap.TweenMax.</span>to
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to = function (target, duration, vars) {
			return new TweenMax(target, duration, vars);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.<span class="apidocCodeKeywordSpan">to</span>(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenMax.prototype" id="apidoc.module.gsap.TweenMax.prototype">module gsap.TweenMax.prototype</a></h1>










    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.constructor" id="apidoc.element.gsap.TweenMax.prototype.constructor">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>constructor
        <span class="apidocSignatureSpan">(target, duration, vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this &#x22;hot&#x22; method)
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.duration" id="apidoc.element.gsap.TweenMax.prototype.duration">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>duration
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duration = function (value) {
			if (!arguments.length) {
				return this._duration; //don&#x27;t set _dirty = false because there could be repeats that haven&#x27;t been factored into the _totalDuration
 yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration
 would not be correct, thus repeats wouldn&#x27;t take effect.
			}
			return Animation.prototype.duration.call(this, value);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					throw(&#x22;Cannot add &#x22; + value + &#x22; into the timeline; it is not a tween, timeline, function, or string.&#x22;);
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again
 so that it renders properly. We should also align the playhead with the parent timeline&#x27;s when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration &#x3c; this.<span class="apidocCodeKeywordSpan
">duration</span>()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() &#x3e; value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the
 current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let
it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue
 that it should jump to its end state, that&#x27;s not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime &#x26;&#x26; tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.invalidate" id="apidoc.element.gsap.TweenMax.prototype.invalidate">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>invalidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidate = function () {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.<span class="apidocCodeKeywordSpan">invalidate</span>();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.progress" id="apidoc.element.gsap.TweenMax.prototype.progress">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>progress
        <span class="apidocSignatureSpan">(value, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress = function (value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo &#x26;&#x26; (this._cycle &#x26;
1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.render" id="apidoc.element.gsap.TweenMax.prototype.render">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>render
        <span class="apidocSignatureSpan">(time, suppressEvents, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 &#x26;&#x26; this.vars.repeat) { //zero duration tweens that render immediately have render
() called from TweenLite&#x27;s constructor, before TweenMax&#x27;s constructor has finished setting _repeat, _repeatDelay, and _yoyo which
 are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime;
			if (time &#x3e;= totalDur - 0.0000001 &#x26;&#x26; time &#x3e;= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo &#x26;&#x26; (this._cycle &#x26; 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = &#x22;onComplete&#x22;;
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it&#x27;s already
 finished, it doesn&#x27;t get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern
 the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the
 &#x22;playhead&#x22; of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should
 be rendered, but if the timeline&#x27;s &#x22;playhead&#x22; moves past it in the backward direction (from a postitive time to a negative time
), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline
 renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the
 way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete
 even though technically the playhead didn&#x27;t pass over it again. It&#x27;s a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime &#x3c; 0 || (time &#x3c;= 0 &#x26;&#x26; time &#x3e;= -0.0000001) || (prevRawPrevTime === _tinyNum &#x26;&#x26; this.data !== &#x22;isPause&#x22;))
if (prevRawPrevTime !== time) { //note: when this.data is &#x22;isPause&#x22;, it&#x27;s a callback added by addPause() on a timeline that we should
 not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn&#x27;t pause.
						force = true;
						if (prevRawPrevTime &#x3e; _tinyNum) {
							callback = &#x22;onReverseComplete&#x22;;
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead
 arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the
 playhead moves again (next time), it&#x27;ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered
 in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine
 doing a timeline.seek(0) and there&#x27;s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing
will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively
expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable
 which would increase memory usage. This technique is less readable, but more efficient.
				}
				
			} else i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if (curTime !== this._time || (this._paused &#x26;&#x26; !prevPaused)) { //in case a tween pauses or seeks the timeline when
 rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime &#x3c;= curTime &#x26;&#x26; !tween._paused &#x26;&#x26; !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.<span class="apidocCodeKeywordSpan">render</span>((time - tween._startTime) * tween._timeScale, suppressEvents, force
);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale
), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.repeat" id="apidoc.element.gsap.TweenMax.prototype.repeat">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>repeat
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.repeatDelay" id="apidoc.element.gsap.TweenMax.prototype.repeatDelay">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>repeatDelay
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeatDelay = function (value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.time" id="apidoc.element.gsap.TweenMax.prototype.time">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>time
        <span class="apidocSignatureSpan">(value, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time = function (value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value &#x3e; this._duration) {
				value = this._duration;
			}
			if (this._yoyo &#x26;&#x26; (this._cycle &#x26; 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function(wrapRepeats) {
			return (wrapRepeats &#x26;&#x26; (this._paused || (this._repeat &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">time</span
>() &#x3e; 0 &#x26;&#x26; this.totalProgress() &#x3c; 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused
 ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.totalDuration" id="apidoc.element.gsap.TweenMax.prototype.totalDuration">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>totalDuration
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">totalDuration = function (value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this
._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					for (i = 0; i &#x3c; l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== &#x22;string&#x22; &#x26;&#x26; typeof(child) !== &#x22;function&#x22;) {
							if (align === &#x22;sequence&#x22;) {
								curTime = child._startTime + (child.<span class="apidocCodeKeywordSpan">totalDuration</span>() / child._timeScale);
							} else if (align === &#x22;start&#x22;) {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.totalProgress" id="apidoc.element.gsap.TweenMax.prototype.totalProgress">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>totalProgress
        <span class="apidocSignatureSpan">(value, suppressEvents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">totalProgress = function (value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents
);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function(wrapRepeats) {
			return (wrapRepeats &#x26;&#x26; (this._paused || (this._repeat &#x26;&#x26; this.time() &#x3e; 0 &#x26;&#x26; this.<span class
="apidocCodeKeywordSpan">totalProgress</span>() &#x3c; 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused
 ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.updateTo" id="apidoc.element.gsap.TweenMax.prototype.updateTo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>updateTo
        <span class="apidocSignatureSpan">(vars, resetDuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateTo = function (vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration &#x26;&#x26; this._startTime &#x3c; this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the
 timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled &#x26;&#x26; this._firstPT) {
						TweenLite._onPluginEvent(&#x22;_onDisable&#x22;, this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration &#x3e; 0.998) { //if the tween has finished (or come extremely close to finishing), we just need
 to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens
that are close to finishing (but haven&#x27;t quite finished) to work this way too because otherwise, the values are so small when determining
 where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when
run backwards.
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time &#x3e; 0 || immediate) {
							var inv = 1 / (1 - curRatio),
								pt = this._firstPT, endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenMax.prototype.yoyo" id="apidoc.element.gsap.TweenMax.prototype.yoyo">
        function <span class="apidocSignatureSpan">gsap.TweenMax.prototype.</span>yoyo
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yoyo = function (value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenPlugin" id="apidoc.module.gsap.TweenPlugin">module gsap.TweenPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin.TweenPlugin" id="apidoc.element.gsap.TweenPlugin.TweenPlugin">
        function <span class="apidocSignatureSpan">gsap.</span>TweenPlugin
        <span class="apidocSignatureSpan">(props, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TweenPlugin = function (props, priority) {
					this._overwriteProps = (props || &#x22;&#x22;).split(&#x22;,&#x22;);
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin.activate" id="apidoc.element.gsap.TweenPlugin.activate">
        function <span class="apidocSignatureSpan">gsap.TweenPlugin.</span>activate
        <span class="apidocSignatureSpan">(plugins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">activate = function (plugins) {
			var i = plugins.length;
			while (--i &#x3e; -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === &#x22;function&#x22;) {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.<span class="apidocCodeKeywordSpan">activate</span>([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it
&#x27;s best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.TweenPlugin.prototype" id="apidoc.module.gsap.TweenPlugin.prototype">module gsap.TweenPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin.prototype._addTween" id="apidoc.element.gsap.TweenPlugin.prototype._addTween">
        function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_addTween
        <span class="apidocSignatureSpan">(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addTween = function (target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
				if (typeof(end) === &#x22;function&#x22;) {
					end = end(index || 0, target);
				}
				var type = typeof(target[prop]),
					getterName = (type !== &#x22;function&#x22;) ? &#x22;&#x22; : ((prop.indexOf(&#x22;set&#x22;) || typeof(target[&#x22;get&#x22; + prop.substr(3)]) !== &#x22;function&#x22;) ?
prop : &#x22;get&#x22; + prop.substr(3)),
					s = (start !== &#x22;get&#x22;) ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
					isRelative = (typeof(end) === &#x22;string&#x22; &#x26;&#x26; end.charAt(1) === &#x22;=&#x22;),
					pt = {t:target, p:prop, s:s, f:(type === &#x22;function&#x22;), pg:0, n:overwriteProp || prop, m:(!mod ? 0 : (typeof(mod) === &#x22;function
&#x22;) ? mod : Math.round), pr:0, c:isRelative ? parseInt(end.charAt(0) + &#x22;1&#x22;, 10) * parseFloat(end.substr(2)) : (parseFloat(end) -
s) || 0},
					blob;

				if (typeof(s) !== &#x22;number&#x22; || (typeof(end) !== &#x22;number&#x22; &#x26;&#x26; !isRelative)) {
					if (funcParam || isNaN(s) || (!isRelative &#x26;&#x26; isNaN(end)) || typeof(s) === &#x22;boolean&#x22; || typeof(end) === &#x22;boolean&#x22;) {
						//a blob (string that has multiple numbers in it)
						pt.fp = funcParam;
						blob = _blobDif(s, (isRelative ? pt.s + pt.c : end), stringFilter || TweenLite.defaultStringFilter, pt);
						pt = {t: blob, p: &#x22;setRatio&#x22;, s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0, m: 0}; //&#x22;2&#x22; indicates it&#x27;s a Blob
 property tween. Needed for RoundPropsPlugin for example.
					} else {
						pt.s = parseFloat(s);
						if (!isRelative) {
							pt.c = (parseFloat(end) - pt.s) || 0;
						}
					}
				}
				if (pt.c) { //only add it to the linked list if there&#x27;s a change.
					if ((pt._next = this._firstPT)) {
						pt._next._prev = pt;
					}
					this._firstPT = pt;
					return pt;
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c) {
			this.<span class="apidocCodeKeywordSpan">_addTween</span>(target, p, s, s + c, p, Math.round);
			this._overwriteProps.push(p);
		};

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin.prototype._kill" id="apidoc.element.gsap.TweenPlugin.prototype._kill">
        function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_kill
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_kill = function (lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i &#x3e; -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (!vars &#x26;&#x26; !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i &#x3e; -1) {
				if (tweens[i].<span class="apidocCodeKeywordSpan">_kill</span>(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin.prototype._mod" id="apidoc.element.gsap.TweenPlugin.prototype._mod">
        function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_mod
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mod = function (lookup) {
			var pt = this._firstPT,
				val;
			while (pt) {
				val = lookup[this._propName] || (pt.n != null &#x26;&#x26; lookup[ pt.n.split(this._propName + &#x22;_&#x22;).join(&#x22;&#x22;) ]);
				if (val &#x26;&#x26; typeof(val) === &#x22;function&#x22;) { //some properties that are very plugin-specific add a prefix named after the _propName
 plus an underscore, so we need to ignore that extra stuff here.
					if (pt.f === 2) {
						pt.t._applyPT.m = val;
					} else {
						pt.m = val;
					}
				}
				pt = pt._next;
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			i = rp.length;
			while (--i &#x3e; -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t.<span class="apidocCodeKeywordSpan">_mod</span>(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 &#x26;&#x26; pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin.prototype._roundProps" id="apidoc.element.gsap.TweenPlugin.prototype._roundProps">
        function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>_roundProps
        <span class="apidocSignatureSpan">(lookup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_roundProps = function (lookup) {
			var pt = this._firstPT,
				val;
			while (pt) {
				val = lookup[this._propName] || (pt.n != null &#x26;&#x26; lookup[ pt.n.split(this._propName + &#x22;_&#x22;).join(&#x22;&#x22;) ]);
				if (val &#x26;&#x26; typeof(val) === &#x22;function&#x22;) { //some properties that are very plugin-specific add a prefix named after the _propName
 plus an underscore, so we need to ignore that extra stuff here.
					if (pt.f === 2) {
						pt.t._applyPT.m = val;
					} else {
						pt.m = val;
					}
				}
				pt = pt._next;
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.TweenPlugin.prototype.setRatio" id="apidoc.element.gsap.TweenPlugin.prototype.setRatio">
        function <span class="apidocSignatureSpan">gsap.TweenPlugin.prototype.</span>setRatio
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setRatio = function (v) {
				var pt = this._firstPT,
					min = 0.000001,
					val;
				while (pt) {
					val = !pt.blob ? pt.c * v + pt.s : (v === 1) ? this.end : v ? this.join(&#x22;&#x22;) : this.start;
					if (pt.m) {
						val = pt.m(val, this._target || pt.t);
					} else if (val &#x3c; min) if (val &#x3e; -min &#x26;&#x26; !pt.blob) { //prevents issues with converting very small numbers to strings in the
browser
						val = 0;
					}
					if (!pt.f) {
						pt.t[pt.p] = val;
					} else if (pt.fp) {
						pt.t[pt.p](pt.fp, val);
					} else {
						pt.t[pt.p](val);
					}
					pt = pt._next;
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gsap.ticker" id="apidoc.module.gsap.ticker">module gsap.ticker</a></h1>


    <h2>
        <a href="#apidoc.element.gsap.ticker.fps" id="apidoc.element.gsap.ticker.fps">
        function <span class="apidocSignatureSpan">gsap.ticker.</span>fps
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fps = function (value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.<span class="apidocCodeKeywordSpan">fps</span>(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout
 that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF === &#x22;auto&#x22; &#x26;&#x26; _self.frame &#x3c; 5 &#x26;&#x26; _doc.visibilityState !== &#x22;hidden&#x22;) {
					_self.useRAF(false);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ticker.lagSmoothing" id="apidoc.element.gsap.ticker.lagSmoothing">
        function <span class="apidocSignatureSpan">gsap.ticker.</span>lagSmoothing
        <span class="apidocSignatureSpan">(threshold, adjustedLag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lagSmoothing = function (threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		TweenLite.version = &#x22;1.19.1&#x22;;
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = &#x22;auto&#x22;;
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.<span class="apidocCodeKeywordSpan">lagSmoothing</span>(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ticker.sleep" id="apidoc.element.gsap.ticker.sleep">
        function <span class="apidocSignatureSpan">gsap.ticker.</span>sleep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sleep = function () {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function(seamless) {
				if (_id !== null) {
					_self.<span class="apidocCodeKeywordSpan">sleep</span>();
				} else if (seamless) {
					_startTime += -_lastUpdate + (_lastUpdate = _getTime());
				} else if (_self.frame &#x3e; 10) { //don&#x27;t trigger lagSmoothing if we&#x27;re just waking up, and make sure that at least
 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time
) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ticker.tick" id="apidoc.element.gsap.ticker.tick">
        function <span class="apidocSignatureSpan">gsap.ticker.</span>tick
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tick = function () {
				_tick(true);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log(&#x22;GSAP encountered missing dependency: &#x22; + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.<span class="apidocCodeKeywordSpan">tick</span
>() to update the time when it is instantiated

})((typeof(module) !== &#x22;undefined&#x22; &#x26;&#x26; module.exports &#x26;&#x26; typeof(global) !== &#x22;undefined&#x22;) ?
global : this || window, &#x22;TweenLite&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ticker.useRAF" id="apidoc.element.gsap.ticker.useRAF">
        function <span class="apidocSignatureSpan">gsap.ticker.</span>useRAF
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useRAF = function (value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout
 that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF === &#x22;auto&#x22; &#x26;&#x26; _self.frame &#x3c; 5 &#x26;&#x26; _doc.visibilityState !== &#x22;hidden&#x22;) {
					_self.<span class="apidocCodeKeywordSpan">useRAF</span>(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gsap.ticker.wake" id="apidoc.element.gsap.ticker.wake">
        function <span class="apidocSignatureSpan">gsap.ticker.</span>wake
        <span class="apidocSignatureSpan">(seamless)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wake = function (seamless) {
				if (_id !== null) {
					_self.sleep();
				} else if (seamless) {
					_startTime += -_lastUpdate + (_lastUpdate = _getTime());
				} else if (_self.frame &#x3e; 10) { //don&#x27;t trigger lagSmoothing if we&#x27;re just waking up, and make sure that at least 10 frames have
 elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time
) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (this === _ticker &#x26;&#x26; !_tickerActive) {
				_ticker.<span class="apidocCodeKeywordSpan">wake</span>();
			}
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i &#x3e; -1) {
				listener = list[i];
...</pre></li>
    </ul>










</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
